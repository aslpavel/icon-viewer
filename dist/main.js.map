{
  "version": 3,
  "sources": ["../src/iter.ts", "../src/ufont.ts", "../src/main.ts"],
  "sourcesContent": [
    "export class Iter<T> {\n    iter: Iterator<T>;\n\n    constructor(iterable: Iterable<T>) {\n        this.iter = iterable[Symbol.iterator]();\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return this.iter;\n    }\n\n    next(): IteratorResult<T> {\n        return this.iter.next();\n    }\n\n    static from<T>(iter: Iterable<T>): Iter<T> {\n        return new Iter(iter);\n    }\n\n    static range(start: number, stop?: number, step: number = 1): Iter<number> {\n        function* rangeGen() {\n            if (stop === undefined) {\n                stop = start;\n                start = 0;\n            }\n            for (let i = start; step > 0 ? i < stop : i > stop; i += step) {\n                yield i;\n            }\n        }\n        return new Iter(rangeGen());\n    }\n\n    static zip<Iters extends any[]>(...iterables: Iters): Iter<ZipItem<Iters>> {\n        const iters = iterables.map((iter) => iter[Symbol.iterator]());\n        const iterCount = iterables.length;\n        function* zipGen() {\n            while (true) {\n                let item = [];\n                for (let iterIndex = 0; iterIndex < iterCount; iterIndex++) {\n                    const iterResult = iters[iterIndex]!.next();\n                    if (iterResult.done) {\n                        return;\n                    }\n                    item.push(iterResult.value);\n                }\n                yield item as ZipItem<Iters>;\n            }\n        }\n        return new Iter(zipGen());\n    }\n\n    zip<O>(other: Iterable<O>): Iter<readonly [T, O]> {\n        return this.applyGenFn(function* zipGen(iter) {\n            const thisIter = iter[Symbol.iterator]();\n            const otherIter = other[Symbol.iterator]();\n            while (true) {\n                let thisItem = thisIter.next();\n                let otherItem = otherIter.next();\n                if (thisItem.done || otherItem.done) {\n                    return;\n                }\n                yield [thisItem.value, otherItem.value] as const;\n            }\n        });\n    }\n\n    enumerate(): Iter<readonly [number, T]> {\n        return this.applyGenFn(function* enumerateGen(iter) {\n            let index = 0;\n            for (let item of iter) {\n                yield [index, item];\n                index += 1;\n            }\n        });\n    }\n\n    map<O>(mapFn: (item: T) => O): Iter<O> {\n        return this.applyGenFn(function* mapGen(iter) {\n            for (let item of iter) {\n                yield mapFn(item);\n            }\n        });\n    }\n\n    filter(predFn: (item: T) => boolean): Iter<T> {\n        return this.applyGenFn(function* filterGen(iter) {\n            for (let item of iter) {\n                if (predFn(item)) {\n                    yield item;\n                }\n            }\n        });\n    }\n\n    filterMap<O>(filterMapFn: (item: T) => O): Iter<NonNullable<O>> {\n        return this.applyGenFn(function* filterMapGen(iter) {\n            for (let outerItem of iter) {\n                const innerItem = filterMapFn(outerItem);\n                if (innerItem) {\n                    yield innerItem;\n                }\n            }\n        });\n    }\n\n    flatMap<O>(flatMapFn: (item: T) => Iterable<O>): Iter<O> {\n        return this.applyGenFn(function* flatMapGen(iter) {\n            for (let outerItem of iter) {\n                let innerItems = flatMapFn(outerItem);\n                if (innerItems) {\n                    for (let innerItem of innerItems) {\n                        yield innerItem;\n                    }\n                }\n            }\n        });\n    }\n\n    forEach(forEachFn: (item: T) => void): void {\n        for (let item of this) {\n            forEachFn(item);\n        }\n    }\n\n    fold<O>(initialValue: O, foldFn: (acc: O, item: T) => O): O {\n        let acc = initialValue;\n        for (let item of this) {\n            acc = foldFn(acc, item);\n        }\n        return acc;\n    }\n\n    collectArray(array: Array<T> | undefined = undefined): Array<T> {\n        array = array === undefined ? new Array() : array;\n        for (const item of this) {\n            array.push(item);\n        }\n        return array;\n    }\n\n    collectSet(set: Set<T> | undefined = undefined): Set<T> {\n        set = set === undefined ? new Set() : set;\n        for (const item of this) {\n            set.add(item);\n        }\n        return set;\n    }\n\n    collectMap<K, V>(\n        this: Iter<readonly [K, V]>,\n        map: Map<K, V> | undefined = undefined\n    ): Map<K, V> {\n        map = map === undefined ? new Map() : map;\n        for (const [key, value] of this) {\n            map.set(key, value);\n        }\n        return map;\n    }\n\n    collectObject<V>(this: Iter<readonly [PropertyKey, V]>): {\n        [k: string]: V;\n    } {\n        return Object.fromEntries(this);\n    }\n\n    private applyGenFn<O>(genFn: (iter: Iterable<T>) => Iterable<O>): Iter<O> {\n        return new Iter(genFn(this));\n    }\n}\n\ntype ZipItem<Iters extends unknown[]> = {\n    readonly [K in keyof Iters]: Iters[K] extends Iterable<infer V> ? V : never;\n};\n",
    "import { Iter } from \"./iter.js\";\n\nexport interface OutlineBuilder {\n    moveTo(p: Point): void;\n    lineTo(p: Point): void;\n    quadTo(p1: Point, p2: Point): void;\n    cubicTo(p1: Point, p2: Point, p3: Point): void;\n    close(): void;\n}\n\nexport class SVGOutlineBuilder implements OutlineBuilder {\n    #chunks: string[];\n    #relative: boolean;\n    #tr: Transform;\n    #pointPrev: Point | null;\n    #numberFormatter: Intl.NumberFormat;\n\n    constructor(\n        relative: boolean = false,\n        precision: number | null = null,\n        tr: Transform | null = null\n    ) {\n        this.#chunks = [];\n        this.#relative = relative;\n        this.#tr = tr ?? Transform.identity();\n        this.#pointPrev = null;\n        this.#numberFormatter = new Intl.NumberFormat(\"en-US\", {\n            useGrouping: false,\n            maximumFractionDigits: precision ?? 2,\n        });\n    }\n\n    #writePoint(p: Point, sep: boolean): Point {\n        p = this.#tr.apply(p);\n        const pp = this.#relative && this.#pointPrev ? p.sub(this.#pointPrev) : p;\n\n        if (sep && pp.x >= 0) {\n            this.#chunks.push(\" \");\n        }\n        this.#chunks.push(this.#numberFormatter.format(pp.x));\n        if (pp.y >= 0) {\n            this.#chunks.push(\",\");\n        }\n        this.#chunks.push(this.#numberFormatter.format(pp.y));\n        return p;\n    }\n\n    moveTo(p: Point): void {\n        this.#chunks.push(this.#relative && this.#pointPrev ? \"m\" : \"M\");\n        this.#pointPrev = this.#writePoint(p, false);\n    }\n\n    lineTo(p: Point): void {\n        this.#chunks.push(this.#relative ? \"l\" : \"L\");\n        this.#pointPrev = this.#writePoint(p, false);\n    }\n\n    quadTo(p1: Point, p2: Point): void {\n        this.#chunks.push(this.#relative ? \"q\" : \"Q\");\n        this.#writePoint(p1, false);\n        this.#pointPrev = this.#writePoint(p2, true);\n    }\n\n    cubicTo(p1: Point, p2: Point, p3: Point): void {\n        this.#chunks.push(this.#relative ? \"c\" : \"C\");\n        this.#writePoint(p1, false);\n        this.#writePoint(p2, true);\n        this.#pointPrev = this.#writePoint(p3, true);\n    }\n\n    close(): void {\n        this.#chunks.push(\"Z\");\n    }\n\n    build(): string {\n        return this.#chunks.join(\"\");\n    }\n}\n\nclass BBoxBuilder implements OutlineBuilder {\n    constructor(public min: Point | null = null, public max: Point | null = null) {}\n\n    extend(p: Point): void {\n        if (this.min === null || this.max === null) {\n            this.min = new Point(p.x, p.y);\n            this.max = new Point(p.x, p.y);\n            return;\n        }\n        if (p.x < this.min.x) {\n            this.min.x = p.x;\n        }\n        if (p.x > this.max.x) {\n            this.max.x = p.x;\n        }\n        if (p.y < this.min.y) {\n            this.min.y = p.y;\n        }\n        if (p.y > this.max.y) {\n            this.max.y = p.y;\n        }\n    }\n\n    moveTo(p: Point): void {\n        this.extend(p);\n    }\n\n    lineTo(p: Point): void {\n        this.extend(p);\n    }\n\n    quadTo(p1: Point, p2: Point): void {\n        this.extend(p1);\n        this.extend(p2);\n    }\n\n    cubicTo(p1: Point, p2: Point, p3: Point): void {\n        this.extend(p1);\n        this.extend(p2);\n        this.extend(p3);\n    }\n\n    close(): void {}\n}\n\nexport class Point {\n    constructor(public x: number, public y: number) {}\n    add(other: Point): Point {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n    sub(other: Point): Point {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n    mul(scalar: number): Point {\n        return new Point(this.x * scalar, this.y * scalar);\n    }\n    lerp(other: Point, ratioOther: number): Point {\n        const ratioThis = 1.0 - ratioOther;\n        return new Point(\n            this.x * ratioThis + other.x * ratioOther,\n            this.y * ratioThis + other.y * ratioOther\n        );\n    }\n    toString(): string {\n        return `Point(${this.x}, ${this.y})`;\n    }\n}\n\nexport class Transform {\n    constructor(\n        public m00: number,\n        public m01: number,\n        public m02: number,\n        public m10: number,\n        public m11: number,\n        public m12: number\n    ) {}\n    static identity(): Transform {\n        return new Transform(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n    }\n    translate(tx: number, ty: number): Transform {\n        return this.matmul(new Transform(1.0, 0.0, tx, 0.0, 1.0, ty));\n    }\n    scale(sx: number, sy: number): Transform {\n        return this.matmul(new Transform(sx, 0.0, 0.0, 0.0, sy, 0.0));\n    }\n    rotate(angle: number): Transform {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return this.matmul(new Transform(cos, -sin, 0.0, sin, cos, 0.0));\n    }\n    matmul(other: Transform): Transform {\n        return new Transform(\n            this.m00 * other.m00 + this.m01 * other.m10,\n            this.m00 * other.m01 + this.m01 * other.m11,\n            this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n            this.m10 * other.m00 + this.m11 * other.m10,\n            this.m10 * other.m01 + this.m11 * other.m11,\n            this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n        );\n    }\n    apply(point: Point): Point {\n        return new Point(\n            point.x * this.m00 + point.y * this.m01 + this.m02,\n            point.x * this.m10 + point.y * this.m11 + this.m12\n        );\n    }\n}\n\ninterface GlyphPoint {\n    coord: Point; // coordinate of the point\n    isOnCurve: boolean; // whether point is on the curve\n    isLast: boolean; // whether it is the last point in the contour\n}\n\nconst ON_CURVE_POINT = 0x01;\nconst X_SHORT_VECTOR = 0x02;\nconst Y_SHORT_VECTOR = 0x04;\nconst REPEAT_FLAG = 0x08;\nconst X_SAME_OR_POS = 0x10;\nconst Y_SAME_OR_POS = 0x20;\n\nconst ARG_1_AND_2_ARE_WORDS = 0x0001;\nconst ARGS_ARE_XY_VALUES = 0x0002;\nconst WE_HAVE_A_SCALE = 0x0008;\nconst MORE_COMPONENTS = 0x0020;\nconst WE_HAVE_AN_X_AND_Y_SCALE = 0x0040;\nconst WE_HAVE_A_TWO_BY_TWO = 0x0080;\n\nexport class Glyph {\n    font: Font;\n    glyphId: GlyphId;\n    contoursCount: number;\n    minPoint: Point;\n    maxPoint: Point;\n    #reader: Reader | null;\n\n    constructor(font: Font, glyphId: number, reader: Reader | null) {\n        this.font = font;\n        this.glyphId = glyphId;\n\n        if (reader && reader.length() !== 0) {\n            this.contoursCount = reader.readI16();\n            this.minPoint = new Point(reader.readI16(), reader.readI16());\n            this.maxPoint = new Point(reader.readI16(), reader.readI16());\n            this.#reader = reader.view(10);\n        } else {\n            this.contoursCount = 0;\n            this.minPoint = new Point(0, 0);\n            this.maxPoint = new Point(0, 0);\n            this.#reader = null;\n        }\n    }\n\n    toString(): string {\n        const { x: width, y: height } = this.maxPoint.sub(this.minPoint);\n        const dataLength = this.#reader ? this.#reader.length() : 0;\n        return `Glyph(size=${[width, height]}, min=${this.minPoint}, contours=${\n            this.contoursCount\n        }, data=${dataLength})`;\n    }\n\n    /**Generate 100x100 SVG path for the glyph */\n    toSVGPath(\n        tr: Transform | null = null,\n        relative: boolean = false,\n        precision: number | null = null\n    ): [string, [Point, Point] | null] {\n        const bbox = this.bbox();\n        if (bbox === null) {\n            return [\"\", null];\n        }\n\n        // move middle of the bbox to the middle of em box\n        const [min, max] = bbox;\n        const mid = min.add(max).mul(0.5);\n        const em = Math.max(\n            this.font.getHeadTable().unitsPerEm,\n            (max.x - min.x) * 1.1,\n            (max.y - max.y) * 1.1\n        );\n        const center = new Point(em / 2, em / 2).sub(mid);\n\n        tr = tr ?? Transform.identity();\n        tr = tr.matmul(\n            new Transform(1, 0, 0, 0, -1, 100)\n                .scale(100 / em, 100 / em)\n                .translate(center.x, center.y)\n        );\n\n        const svgPath = this.buildOutline(new SVGOutlineBuilder(relative, precision, tr)).build();\n        return [svgPath, bbox];\n    }\n\n    /**\n     * BBox in the glyph is not always correct (i.e fluent icons)\n     *\n     * This is an approximate bbox based on all points (real bbox can be smaller)\n     */\n    bbox(): [Point, Point] | null {\n        if (this.contoursCount < 0) {\n            const bbox = this.buildOutline(new BBoxBuilder());\n            if (bbox.min === null || bbox.max === null) {\n                return null;\n            }\n            return [bbox.min, bbox.max];\n        } else if (this.contoursCount === 0) {\n            return null;\n        } else {\n            const bbox = Iter.from(this.#simpleOutlinePoints()).fold(\n                new BBoxBuilder(),\n                (bbox, point) => {\n                    bbox.extend(point.coord);\n                    return bbox;\n                }\n            );\n            if (bbox.min === null || bbox.max === null) {\n                return null;\n            }\n            return [bbox.min, bbox.max];\n        }\n    }\n\n    /** Build outline fot the glyph */\n    buildOutline<B extends OutlineBuilder>(builder: B, tr: Transform | null = null): B {\n        if (this.contoursCount >= 0) {\n            this.#buildSimpleOutline(builder, tr);\n        } else {\n            this.#buildCompositeOutline(builder, tr);\n        }\n        return builder;\n    }\n\n    /** Build simple outline\n     *\n     * Reference: {@link http://chanae.walon.org/pub/ttf/ttf_glyphs.htm}\n     * Notes:\n     *  - [on0, on1] - line\n     *  - [on0, off, on1] - quad(on0, off, on1)\n     *  - [on0, off0, off1, on1] - quad(on0, off0, (off0+off1)/2) quad((off0+off1)/2, off1, on1)\n     */\n    #buildSimpleOutline(builder: OutlineBuilder, tr: Transform | null): void {\n        tr = tr ?? Transform.identity();\n        let firstOnCurve: Point | null = null;\n        let firstOffCurve: Point | null = null;\n        let lastOffCurve: Point | null = null;\n        for (const point of this.#simpleOutlinePoints()) {\n            if (firstOnCurve === null) {\n                if (point.isOnCurve) {\n                    firstOnCurve = point.coord;\n                    builder.moveTo(tr.apply(point.coord));\n                } else {\n                    if (firstOffCurve) {\n                        const mid = firstOffCurve.lerp(point.coord, 0.5);\n                        firstOnCurve = mid;\n                        lastOffCurve = point.coord;\n                        builder.moveTo(tr.apply(mid));\n                    } else {\n                        firstOffCurve = point.coord;\n                    }\n                }\n            } else {\n                if (lastOffCurve) {\n                    if (point.isOnCurve) {\n                        builder.quadTo(tr.apply(lastOffCurve), tr.apply(point.coord));\n                        lastOffCurve = null;\n                    } else {\n                        const mid = lastOffCurve.lerp(point.coord, 0.5);\n                        builder.quadTo(tr.apply(lastOffCurve), tr.apply(mid));\n                        lastOffCurve = point.coord;\n                    }\n                } else {\n                    if (point.isOnCurve) {\n                        builder.lineTo(tr.apply(point.coord));\n                    } else {\n                        lastOffCurve = point.coord;\n                    }\n                }\n            }\n\n            if (point.isLast) {\n                if (firstOffCurve && lastOffCurve) {\n                    const mid = lastOffCurve.lerp(firstOffCurve, 0.5);\n                    builder.quadTo(tr.apply(lastOffCurve), tr.apply(mid));\n                    lastOffCurve = null;\n                }\n                if (firstOnCurve) {\n                    if (firstOffCurve) {\n                        builder.quadTo(tr.apply(firstOffCurve), tr.apply(firstOnCurve));\n                    } else if (lastOffCurve) {\n                        builder.quadTo(tr.apply(lastOffCurve), tr.apply(firstOnCurve));\n                    } else {\n                        builder.lineTo(tr.apply(firstOnCurve));\n                    }\n                }\n                builder.close();\n                firstOnCurve = null;\n                firstOffCurve = null;\n                lastOffCurve = null;\n            }\n        }\n    }\n\n    /**\n     * Simple glyph outline\n     *\n     * Reference:\n     * {@link https://learn.microsoft.com/en-us/typography/opentype/spec/glyf#simple-glyph-description}\n     */\n    #simpleOutlinePoints = function* (this: Glyph): Generator<GlyphPoint> {\n        if (this.contoursCount == 0) {\n            return;\n        }\n\n        const reader = this.#reader!;\n        reader.seek(0);\n\n        let pointsCount = 0;\n        const endPoints = Iter.range(this.contoursCount)\n            .map((_) => {\n                let value = reader.readU16();\n                pointsCount = value;\n                return value;\n            })\n            .collectSet();\n        pointsCount = pointsCount + 1;\n\n        // should be ignored but not an error\n        if (pointsCount == 1) {\n            return;\n        }\n\n        // skip instructions bytecode\n        const instructionsLen = reader.readU16();\n        reader.advance(instructionsLen);\n\n        let xLen = 0;\n        let yLen = 0;\n        let flagsLeft = pointsCount;\n        let flags: number[] = [];\n        while (flagsLeft > 0) {\n            const flag = reader.readU8();\n\n            let repeats = 1;\n            flags.push(flag);\n            if (flag & REPEAT_FLAG) {\n                repeats += reader.readU8();\n                for (const _ of Iter.range(repeats - 1)) {\n                    flags.push(flag);\n                }\n            }\n            if (repeats > flagsLeft) {\n                break;\n            }\n            flagsLeft -= repeats;\n\n            if (flag & X_SHORT_VECTOR) {\n                xLen += repeats; // read u8\n            } else if (!(flag & X_SAME_OR_POS)) {\n                xLen += repeats * 2; // read u16\n            }\n            if (flag & Y_SHORT_VECTOR) {\n                yLen += repeats;\n            } else if (!(flag & Y_SAME_OR_POS)) {\n                yLen += repeats * 2;\n            }\n        }\n\n        // create x and y readers\n        const xStart = reader.tell(),\n            yStart = xStart + xLen,\n            yEnd = yStart + yLen;\n        const xRreader = reader.view(xStart, yStart);\n        const yReader = reader.view(yStart, yEnd);\n\n        // reader points\n        let x = 0;\n        let y = 0;\n        for (const [index, flag] of Iter.from(flags).enumerate()) {\n            let xDiff = 0;\n            const notXSameOrPos = !(flag & X_SAME_OR_POS);\n            if (flag & X_SHORT_VECTOR) {\n                xDiff = xRreader.readU8();\n                if (notXSameOrPos) {\n                    xDiff = -xDiff;\n                }\n            } else if (notXSameOrPos) {\n                xDiff = xRreader.readI16();\n            }\n            x += xDiff;\n\n            let yDiff = 0;\n            const notYSameOrPos = !(flag & Y_SAME_OR_POS);\n            if (flag & Y_SHORT_VECTOR) {\n                yDiff = yReader.readU8();\n                if (notYSameOrPos) {\n                    yDiff = -yDiff;\n                }\n            } else if (notYSameOrPos) {\n                yDiff = yReader.readI16();\n            }\n            y += yDiff;\n\n            yield {\n                coord: new Point(x, y),\n                isOnCurve: Boolean(flag & ON_CURVE_POINT),\n                isLast: endPoints.has(index),\n            };\n        }\n    };\n\n    #buildCompositeOutline(builder: OutlineBuilder, tr: Transform | null): void {\n        tr = tr ?? Transform.identity();\n\n        const reader = this.#reader!;\n        reader.seek(0);\n\n        const glyfTable = this.font.getGlyfTable()!;\n        while (true) {\n            const flag = reader.readU16();\n\n            // find child glyph\n            const glyphId = reader.readU16();\n            const glyph = glyfTable.glyphs.at(glyphId);\n            if (glyph === undefined) {\n                console.error(\n                    `[${this.font.getNameTable().family}][${\n                        this.glyphId\n                    }] requested invalid glyph ${glyphId}`\n                );\n                if (!(flag & MORE_COMPONENTS)) {\n                    break;\n                }\n                continue;\n            }\n\n            let [m00, m01, m02, m10, m11, m12] = [1, 0, 0, 0, 1, 0];\n            if (flag & ARGS_ARE_XY_VALUES) {\n                if (flag & ARG_1_AND_2_ARE_WORDS) {\n                    m02 = reader.readI16();\n                    m12 = reader.readI16();\n                } else {\n                    m02 = reader.readI8();\n                    m12 = reader.readI8();\n                }\n            }\n            if (flag & WE_HAVE_A_TWO_BY_TWO) {\n                m00 = reader.read2FDot14();\n                m10 = reader.read2FDot14();\n                m01 = reader.read2FDot14();\n                m11 = reader.read2FDot14();\n            } else if (flag & WE_HAVE_AN_X_AND_Y_SCALE) {\n                m00 = reader.read2FDot14();\n                m11 = reader.read2FDot14();\n            } else if (flag & WE_HAVE_A_SCALE) {\n                m00 = reader.read2FDot14();\n                m11 = m00;\n            }\n            const ts = new Transform(m00, m01, m02, m10, m11, m12);\n\n            // build child glyph\n            glyph.buildOutline(builder, tr.matmul(ts));\n\n            if (!(flag & MORE_COMPONENTS)) {\n                break;\n            }\n        }\n    }\n}\n\nexport class Reader {\n    #view: DataView;\n    #position: number;\n\n    constructor(view: DataView) {\n        this.#view = view;\n        this.#position = 0;\n    }\n\n    data(): ArrayBuffer {\n        const offset = this.#view.byteOffset;\n        return this.#view.buffer.slice(offset, offset + this.#view.byteLength);\n    }\n\n    length(): number {\n        return this.#view.byteLength;\n    }\n\n    tell(): number {\n        return this.#position;\n    }\n\n    seek(pos: number, absolute: boolean = true): number {\n        if (!absolute) {\n            this.#position += pos;\n        } else if (pos >= 0) {\n            this.#position = pos;\n        } else if (pos < 0) {\n            this.#position = this.#view.byteLength + pos;\n        }\n        return this.advance(0);\n    }\n\n    advance(size: number): number {\n        const position = this.#position + size;\n        this.#position = Math.max(0, Math.min(position, this.#view.byteLength));\n        return this.#position;\n    }\n\n    view(start: number | null = 0, end: number | null = null): Reader {\n        if (start === null) {\n            start = this.#position;\n        } else {\n            start = Math.max(0, Math.min(start, this.#view.byteLength));\n        }\n        if (end === null) {\n            end = this.#view.byteLength;\n        } else {\n            end = Math.max(start, Math.min(end, this.#view.byteLength));\n        }\n        const view = new DataView(this.#view.buffer, this.#view.byteOffset + start, end - start);\n        return new Reader(view);\n    }\n\n    read(size: number): Uint8Array {\n        const result = new Uint8Array(\n            this.#view.buffer,\n            this.#view.byteOffset + this.#position,\n            size\n        );\n        this.advance(size);\n        return result;\n    }\n\n    readString(size: number): string {\n        const decoder = new TextDecoder();\n        return decoder.decode(this.read(size));\n    }\n\n    readU8(): number {\n        const result = this.#view.getUint8(this.#position);\n        this.advance(1);\n        return result;\n    }\n\n    readI8(): number {\n        const result = this.#view.getInt8(this.#position);\n        this.advance(1);\n        return result;\n    }\n\n    readU16(): number {\n        const result = this.#view.getUint16(this.#position);\n        this.advance(2);\n        return result;\n    }\n\n    readI16(): number {\n        const result = this.#view.getInt16(this.#position);\n        this.advance(2);\n        return result;\n    }\n\n    readU32(): number {\n        const result = this.#view.getUint32(this.#position);\n        this.advance(4);\n        return result;\n    }\n\n    readI32(): number {\n        const result = this.#view.getInt32(this.#position);\n        this.advance(4);\n        return result;\n    }\n\n    readU64(): bigint {\n        const result = this.#view.getBigUint64(this.#position);\n        this.advance(8);\n        return result;\n    }\n\n    readI64(): bigint {\n        const result = this.#view.getBigInt64(this.#position);\n        this.advance(8);\n        return result;\n    }\n\n    readFixed(): number {\n        return this.readI32() / 65536.0;\n    }\n\n    read2FDot14(): number {\n        return this.readI16() / 16384.0;\n    }\n\n    readLongDate(): Date {\n        const timestamp = this.readI64() - 2082844800n; // 1904-01-01\n        return new Date(Number(timestamp) * 1_000);\n    }\n\n    toString(): string {\n        return `Reader(postion=${this.#position}, size=${this.#view.byteLength})`;\n    }\n}\n\nclass FontTable {\n    constructor(public checksum: number, public offset: number, public length: number) {}\n\n    reader(font: Font): Reader {\n        return new Reader(new DataView(font.data, this.offset, this.length));\n    }\n}\n\ntype GlyphId = number;\ntype Codepoint = number;\n\nconst SPECIMEN_SIZE = 32;\nconst SPECIMEN_PADD = 6;\nconst SPECIMEN_COLS = 35;\n\n/**\n * Simple font reader\n *\n * References:\n *     - {@link https://tchayen.github.io/posts/ttf-file-parsing}\n *     - {@link https://learn.microsoft.com/en-us/typography/opentype/spec/otff#organization-of-an-opentype-font}\n */\nexport class Font {\n    #data: ArrayBuffer;\n    #cache: Map<string, any>;\n    name: NameTable;\n    fontType: \"ttf\" | \"otf\";\n    tables: Map<string, FontTable>;\n    glyphCount: number;\n\n    constructor(data: ArrayBuffer) {\n        this.#data = data;\n        this.tables = new Map();\n        this.#cache = new Map();\n\n        const headerReader = new Reader(new DataView(this.#data));\n        const sfntVersion = headerReader.readU32();\n        if (sfntVersion === 0x00010000) {\n            this.fontType = \"ttf\";\n        } else if (sfntVersion === 0x4f54544f) {\n            this.fontType = \"otf\";\n        } else {\n            throw new Error(`Unkown font type: ${sfntVersion}`);\n        }\n        const numTables = headerReader.readU16();\n        headerReader.readU16(); // searchRange\n        headerReader.readU16(); // entrySelector\n        headerReader.readU16(); // rangeShift\n\n        // parse tables\n        for (let index = 0; index < numTables; index++) {\n            const tag = headerReader.readString(4);\n            this.tables.set(\n                tag,\n                new FontTable(\n                    headerReader.readU32(),\n                    headerReader.readU32(),\n                    headerReader.readU32()\n                )\n            );\n        }\n\n        // Maximum Profile (required table)\n        // Reference: https://learn.microsoft.com/en-us/typography/opentype/spec/maxp\n        const maxpReader = this.tables.get(\"maxp\")!.reader(this);\n        maxpReader.advance(4); // offset + version\n        this.glyphCount = maxpReader.readU16(); // numGlyphs\n\n        this.name = this.getNameTable();\n    }\n\n    get data(): ArrayBuffer {\n        return this.#data;\n    }\n\n    toString(): string {\n        const name = this.getNameTable();\n        return `Font(family=${name.family}, subfamily=${name.subfamily}, glyph_count=${this.glyphCount})`;\n    }\n\n    /** Get glyph corresponding to the codepoint */\n    glyphByCodepoint(codepoint: Codepoint): Glyph | null {\n        if (this.fontType != \"ttf\") {\n            throw new Error(\"Only TTF outlines are supported for now\");\n        }\n        const glyfTable = this.getGlyfTable();\n        if (glyfTable === null) {\n            return null;\n        }\n        const cmapTable = this.getCmapTable();\n        const glyphId = cmapTable.codepointToGlyphId.get(codepoint);\n        if (glyphId === undefined) {\n            return null;\n        }\n        return glyfTable.glyphs.at(glyphId)!;\n    }\n\n    /** Mapping from names to codepoints as per */\n    get codepointByName(): Map<string, Codepoint> {\n        const cacheName = \"codepointByName\";\n        let nameToCodepoint = this.#cache.get(cacheName);\n        if (nameToCodepoint === undefined) {\n            const cmapTable = this.getCmapTable();\n            const postTable = this.getPostTable();\n            nameToCodepoint = new Map();\n            for (const glyphId of Iter.range(this.glyphCount)) {\n                const name = postTable.glyphIdToName.get(glyphId);\n                const codepoint = cmapTable.glyphIdToCodepoint.get(glyphId);\n                if (name === undefined || codepoint === undefined || codepoint === 0) {\n                    continue;\n                }\n                nameToCodepoint.set(name, codepoint);\n            }\n            this.#cache.set(cacheName, nameToCodepoint);\n        }\n        return nameToCodepoint;\n    }\n\n    specimen(\n        size: number | null = null,\n        columns: number | null = null,\n        padding: number | null = null\n    ): string {\n        size = size ?? SPECIMEN_SIZE;\n        columns = columns ?? SPECIMEN_COLS;\n        padding = padding ?? SPECIMEN_PADD;\n\n        const glyphTable = this.getGlyfTable();\n        if (glyphTable === null || this.glyphCount === 0) {\n            return \"\";\n        }\n\n        const chunks: string[] = [];\n\n        // mark top-left corner\n        chunks.push(\"M0,0h1v1h-1z\");\n\n        const scale = size / 100.0;\n        size += padding;\n        let row = 0,\n            index = 0;\n        for (const glyph of glyphTable.glyphs) {\n            if (glyph.contoursCount === 0) {\n                continue;\n            }\n            row = Math.floor(index / columns);\n            const col = index % columns;\n            const tr = Transform.identity()\n                .translate(padding + col * size, padding + row * size)\n                .scale(scale, scale);\n            const [svgPath, bbox] = glyph.toSVGPath(tr, true);\n            if (bbox === null) {\n                continue;\n            }\n            const bboxSize = bbox[1].sub(bbox[0]);\n            if (bboxSize.x === 0 || bboxSize.y === 0) {\n                continue;\n            }\n            chunks.push(svgPath);\n            chunks.push(\"\\n\");\n            index += 1;\n        }\n\n        // mark bottom-right corner\n        const markX = padding + columns * size,\n            markY = padding + (row + 1) * size;\n        chunks.push(`M${markX},${markY}h1v1h-1z`);\n\n        return chunks.join(\"\");\n    }\n\n    info() {\n        const nameTable = this.getNameTable();\n        const headTable = this.getHeadTable();\n        return {\n            family: nameTable.family,\n            subfamily: nameTable.subfamily,\n            version: nameTable.version,\n            glyph_count: this.glyphCount,\n            post_count: this.getPostTable().glyphIdToName.size,\n            units_per_em: headTable.unitsPerEm,\n            modified_dt: headTable.modifiedDate.toISOString(),\n            tables: Iter.from(this.tables)\n                .map(([name, table]) => [name, table.length] as const)\n                .collectObject(),\n        };\n    }\n\n    #tableGet<T>(name: string, loader: (font: Font, reader: Reader) => T): T {\n        let table: T = this.#cache.get(name);\n        if (table === undefined) {\n            const tableDesc = this.tables.get(name);\n            if (tableDesc === undefined) {\n                throw new Error(`Table not found: ${name}`);\n            }\n            table = loader(this, tableDesc.reader(this));\n            this.#cache.set(name, table);\n        }\n        return table;\n    }\n\n    getNameTable(): NameTable {\n        return this.#tableGet(\"name\", NameTable.load);\n    }\n\n    getHeadTable(): HeadTable {\n        return this.#tableGet(\"head\", HeadTable.load);\n    }\n\n    getPostTable(): PostTable {\n        return this.#tableGet(\"post\", PostTable.load);\n    }\n\n    getCmapTable(): CmapTable {\n        return this.#tableGet(\"cmap\", CmapTable.load);\n    }\n\n    getLocaTable(): LocaTable | null {\n        if (this.tables.get(\"loca\") === undefined) {\n            return null;\n        }\n        return this.#tableGet(\"loca\", LocaTable.load);\n    }\n\n    getGlyfTable(): GlyfTable | null {\n        if (this.tables.get(\"glyf\") === undefined) {\n            return null;\n        }\n        return this.#tableGet(\"glyf\", GlyfTable.load);\n    }\n\n    getHheaTable(): HheaTable {\n        return this.#tableGet(\"hhea\", HheaTable.load);\n    }\n\n    getHmtxTable(): HmtxTable {\n        return this.#tableGet(\"hmtx\", HmtxTable.load);\n    }\n}\n\n/**\n * Name table (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/name}\n */\nexport class NameTable {\n    constructor(\n        public copyright: string,\n        public family: string,\n        public subfamily: string,\n        public fontId: string,\n        public fullname: string,\n        public version: string\n    ) {}\n\n    static load(_font: Font, reader: Reader): NameTable {\n        reader.readU16(); // version\n        const recordCount = reader.readU16();\n        const storageOffset = reader.readU16();\n\n        type NameRecord = {\n            platfromId: number;\n            encodingId: number;\n            langaugeId: number;\n            nameId: number;\n            lenght: number;\n            offset: number;\n        };\n\n        const records: NameRecord[] = [];\n        for (let index = 0; index < recordCount; index++) {\n            const record = {\n                platfromId: reader.readU16(),\n                encodingId: reader.readU16(),\n                langaugeId: reader.readU16(),\n                nameId: reader.readU16(),\n                lenght: reader.readU16(),\n                offset: reader.readU16(),\n            };\n            if (record.platfromId !== 3) {\n                continue;\n            }\n            if (record.langaugeId !== 1033) {\n                continue;\n            }\n            if (record.encodingId in [1, 10]) {\n                records.push(record);\n            }\n        }\n\n        const fields: [string, string, string, string, string, string] = [\"\", \"\", \"\", \"\", \"\", \"\"];\n        const decoder = new TextDecoder(\"utf-16be\");\n        for (const record of records) {\n            if (record.nameId > 5) {\n                continue;\n            }\n            reader.seek(storageOffset + record.offset);\n            const bytes = reader.read(record.lenght);\n            fields[record.nameId] = decoder.decode(bytes);\n        }\n        return new NameTable(...fields);\n    }\n}\n\n/**\n * Header Table (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/head}\n */\nexport class HeadTable {\n    constructor(\n        public revision: number,\n        public flags: number,\n        public unitsPerEm: number,\n        public createdDate: Date,\n        public modifiedDate: Date,\n        public minPoint: Point,\n        public maxPoint: Point,\n        public macStyle: number,\n        public lowestRecPpem: number,\n        public fontDirectionHint: number,\n        public indexToLocFormat: number,\n        public glyphDataFormat: number\n    ) {}\n\n    static load(_font: Font, reader: Reader): HeadTable {\n        reader.readU16(); // majorVersion = 1\n        reader.readU16(); // minorVersion = 0\n        const fontRevision = reader.readFixed();\n        reader.readU32(); // checksum\n        console.assert(reader.readU32() === 0x5f0f3cf5); // magicNumber\n        const flags = reader.readU16();\n        const unitsPerEm = reader.readU16();\n        const createdDate = reader.readLongDate();\n        const modifiedDate = reader.readLongDate();\n        const minPoint = new Point(reader.readI16(), reader.readI16());\n        const maxPoint = new Point(reader.readI16(), reader.readI16());\n        const macStyle = reader.readU16();\n        const lowestRecPpem = reader.readU16();\n        const fontDirectionHint = reader.readI16();\n        const indexToLocFormat = reader.readI16();\n        const glyphDataFormat = reader.readI16();\n        return new HeadTable(\n            fontRevision,\n            flags,\n            unitsPerEm,\n            createdDate,\n            modifiedDate,\n            minPoint,\n            maxPoint,\n            macStyle,\n            lowestRecPpem,\n            fontDirectionHint,\n            indexToLocFormat,\n            glyphDataFormat\n        );\n    }\n}\n\n/**\n * PostScript Table (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/post}\n */\nexport class PostTable {\n    constructor(public glyphIdToName: Map<GlyphId, string>) {}\n\n    toString(): string {\n        return `PostTable(count=${this.glyphIdToName.size})`;\n    }\n\n    static load(_font: Font, reader: Reader): PostTable {\n        const version = reader.readFixed();\n        if (version !== 2) {\n            return new PostTable(new Map());\n        }\n        reader.advance(28); // skip header\n\n        // https://learn.microsoft.com/en-us/typography/opentype/spec/post#version-20\n        const glyphCount = reader.readU16();\n        const glyphIdToIndex: Map<GlyphId, number> = new Map();\n        let maxIndex = 0;\n        for (let glyphIndex = 0; glyphIndex < glyphCount; glyphIndex++) {\n            const nameIndex = reader.readU16();\n            if (nameIndex > 258) {\n                const index = nameIndex - 258;\n                maxIndex = Math.max(maxIndex, index);\n                glyphIdToIndex.set(glyphIndex, index);\n            }\n        }\n\n        const names: string[] = [];\n        const namesCount = maxIndex + 1;\n        for (let _i = 0; _i < namesCount; _i++) {\n            const length = reader.readU8();\n            names.push(reader.readString(length));\n        }\n\n        const glyphIdToName: Map<GlyphId, string> = new Map();\n        for (const [glyphId, index] of glyphIdToIndex) {\n            glyphIdToName.set(glyphId, names[index]!);\n        }\n        return new PostTable(glyphIdToName);\n    }\n}\n\n/**\n * Character Map (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/cmap}\n */\nexport class CmapTable {\n    constructor(\n        public codepointToGlyphId: Map<Codepoint, GlyphId>,\n        public glyphIdToCodepoint: Map<GlyphId, Codepoint>\n    ) {}\n\n    toString(): string {\n        return `CmapTable(count=${this.codepointToGlyphId.size})`;\n    }\n\n    static load(_font: Font, reader: Reader): CmapTable {\n        reader.readU16(); // version\n\n        // find unicode sub-table\n        let unicodeTableOffset = 0;\n        const numTables = reader.readU16();\n        for (let _i = 0; _i < numTables; _i++) {\n            const platformId = reader.readU16(); // 0 - unicode\n            const encodingId = reader.readU16();\n            const subTableOffset = reader.readU32();\n            if (platformId === 0 && encodingId === 4) {\n                unicodeTableOffset = subTableOffset;\n            } else if (!unicodeTableOffset && platformId === 0 && encodingId === 3) {\n                unicodeTableOffset = subTableOffset;\n            }\n        }\n        if (!unicodeTableOffset) {\n            throw new Error(\"Only support unicode (0) format (4, 3) cmap tables\");\n        }\n\n        // sub-table header\n        reader.seek(unicodeTableOffset);\n        const subtableFormat = reader.readU16();\n        const cmap = new CmapTable(new Map(), new Map());\n\n        if (subtableFormat === 12) {\n            // https://learn.microsoft.com/en-us/typography/opentype/spec/cmap#format-12-segmented-coverage\n            reader.readU16(); // reserved\n            reader.readU32(); // length\n            reader.readU32(); // language\n\n            const numGroups = reader.readU32();\n            for (let _i = 0; _i < numGroups; _i++) {\n                const codepointStart = reader.readU32();\n                const codepointEnd = reader.readU32() + 1;\n                let glyphId = reader.readU32();\n                for (let codepoint = codepointStart; codepoint < codepointEnd; codepoint++) {\n                    cmap.glyphIdToCodepoint.set(glyphId, codepoint);\n                    cmap.codepointToGlyphId.set(codepoint, glyphId);\n                    glyphId += 1;\n                }\n            }\n        } else if (subtableFormat == 4) {\n            // https://learn.microsoft.com/en-us/typography/opentype/spec/cmap#format-4-segment-mapping-to-delta-values\n            const stLength = reader.readU16();\n            const stReader = reader.view(reader.tell(), reader.tell() + stLength);\n            stReader.advance(2); // language\n\n            const segmentCount = Math.floor(stReader.readU16() / 2);\n            stReader.advance(6); // searchRange, entrySelector, rangeShift\n            const numGroups = reader.readU32();\n            const endCodes = Iter.range(segmentCount)\n                .map((_) => stReader.readU16())\n                .collectArray();\n            stReader.readU16(); // reserved\n            const startCodes = Iter.range(segmentCount)\n                .map((_) => stReader.readU16())\n                .collectArray();\n            const idDeltas = Iter.range(segmentCount)\n                .map((_) => stReader.readI16())\n                .collectArray();\n            const idRangeOffsets = Iter.range(segmentCount)\n                .map((_) => stReader.readU16())\n                .collectArray();\n            const glyphIdArrayLen = (stReader.length() - stReader.tell()) / 2;\n            const _glyphIdArray = Iter.range(glyphIdArrayLen)\n                .map((_) => stReader.readU16())\n                .collectArray();\n\n            for (const [endCode, startCode, idDelta, idRangeOffset] of Iter.zip(\n                endCodes,\n                startCodes,\n                idDeltas,\n                idRangeOffsets\n            )) {\n                if (endCode === startCode && startCode === 0xffff) {\n                    break;\n                }\n                for (const codepoint of Iter.range(startCode, endCode + 1)) {\n                    if (idRangeOffset != 0) {\n                        console.error(\"[cmap][format=4] idRangeOffset != not implemented\");\n                        break;\n                    }\n                    const glyphId = (codepoint + idDelta) % 65536;\n                    cmap.glyphIdToCodepoint.set(glyphId, codepoint);\n                    cmap.codepointToGlyphId.set(codepoint, glyphId);\n                }\n            }\n        }\n\n        return cmap;\n    }\n}\n\n/**\n * Glyph index to location table (TTF)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/loca}\n */\nexport class LocaTable {\n    constructor(public offsets: number[]) {}\n\n    static load(font: Font, reader: Reader): LocaTable {\n        let readOffset: (index: number) => number;\n        if (font.getHeadTable().indexToLocFormat == 0) {\n            readOffset = (_) => 2 * reader.readU16();\n        } else {\n            readOffset = (_) => reader.readU32();\n        }\n        const offsets = Iter.range(font.glyphCount + 1)\n            .map(readOffset)\n            .collectArray();\n        return new LocaTable(offsets);\n    }\n}\n\n/**\n * Glyph data (TTF)\n * Reference:\n *   - {@link https://learn.microsoft.com/en-us/typography/opentype/spec/glyf}\n */\nexport class GlyfTable {\n    constructor(public glyphs: Glyph[]) {}\n\n    toString(): string {\n        return `GlyphTable(count=${this.glyphs.length})`;\n    }\n\n    static load(font: Font, reader: Reader): GlyfTable | null {\n        const locaTable = font.getLocaTable();\n        if (!locaTable) {\n            return null;\n        }\n        const glyphs = Iter.range(font.glyphCount)\n            .map((index) => {\n                const offsetStart = locaTable.offsets[index];\n                const offsetEnd = locaTable.offsets[index + 1];\n                const glyphReader = reader.view(offsetStart, offsetEnd);\n                return new Glyph(font, index, glyphReader);\n            })\n            .collectArray();\n        return new GlyfTable(glyphs);\n    }\n}\n\n/**\n * Horizontal header table (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/hhea}\n */\nexport class HheaTable {\n    constructor(\n        public ascender: number,\n        public descender: number,\n        public lineGap: number,\n        public advanceWidthMax: number,\n        public minLeftSideBearing: number,\n        public minRightSideBearing: number,\n        public xMaxExtent: number,\n        public caretSlopeRise: number,\n        public caretSlopeRun: number,\n        public caretOffset: number,\n        public numberOfMetrics: number\n    ) {}\n\n    static load(_font: Font, reader: Reader): HheaTable {\n        console.assert(reader.readU16() == 1); // majorVersion\n        console.assert(reader.readU16() == 0); // minorVersion\n        const ascender = reader.readI16();\n        const descender = reader.readI16();\n        const lineGap = reader.readI16();\n        const advanceWidthMax = reader.readU16();\n        const minLeftSideBearing = reader.readI16();\n        const minRightSideBearing = reader.readI16();\n        const xMaxExtent = reader.readI16();\n        const caretSlopeRise = reader.readI16();\n        const caretSlopeRun = reader.readI16();\n        const caretOffset = reader.readI16();\n        reader.advance(10); // reserved + metric_data_format (always 0)\n        const numberOfMetrics = reader.readU16();\n        return new HheaTable(\n            ascender,\n            descender,\n            lineGap,\n            advanceWidthMax,\n            minLeftSideBearing,\n            minRightSideBearing,\n            xMaxExtent,\n            caretSlopeRise,\n            caretSlopeRun,\n            caretOffset,\n            numberOfMetrics\n        );\n    }\n}\n\ntype Metrics = { advance: number; sideBearing: number };\n\n/**\n * Horizontal Metrics Table (required)\n * Reference: {@link https://learn.microsoft.com/en-us/typography/opentype/spec/hmtx}\n */\nexport class HmtxTable {\n    constructor(\n        public metrics: Metrics[],\n        public bearings: number[],\n        public numberOfMetrics: number\n    ) {}\n\n    getAdvance(glyphId: GlyphId): number | undefined {\n        if (glyphId >= this.numberOfMetrics) {\n            return undefined;\n        }\n        if (glyphId < this.metrics.length) {\n            this.metrics.at(glyphId)?.advance;\n        }\n        return this.metrics.at(-1)?.advance;\n    }\n\n    getSideBearing(glyphId: GlyphId): number | undefined {\n        if (glyphId < this.metrics.length) {\n            return this.metrics.at(glyphId)?.sideBearing;\n        } else {\n            const bearingOffset = glyphId - this.metrics.length;\n            return this.bearings.at(bearingOffset);\n        }\n    }\n\n    toString(): string {\n        return `HmtxTable(numberOfMetrix=${this.numberOfMetrics})`;\n    }\n\n    static load(font: Font, reader: Reader): HmtxTable {\n        const hheaTable = font.getHheaTable();\n        let numberOfMetrics = hheaTable.numberOfMetrics;\n        const metrics = Iter.range(numberOfMetrics)\n            .map((_) => {\n                return {\n                    advance: reader.readU16(),\n                    sideBearing: reader.readI16(),\n                };\n            })\n            .collectArray();\n        const bearingCount = font.glyphCount - numberOfMetrics;\n        let bearings: number[] = [];\n        if (bearingCount > 0) {\n            numberOfMetrics += bearingCount;\n            bearings = Iter.range(bearingCount)\n                .map((_) => reader.readI16())\n                .collectArray();\n        }\n        return new HmtxTable(metrics, bearings, numberOfMetrics);\n    }\n}\n",
    "import { Iter } from \"./iter.js\";\nimport { Font as UFont, Glyph as UGlyph } from \"./ufont.js\";\n\nexport class Font {\n    family: string;\n    ufont: UFont;\n    icons: Map<string, Icon>;\n\n    constructor(family: string, ufont: UFont, nameToCodepoint: { [k: string]: number }) {\n        const icons = new Iter(Object.entries(nameToCodepoint))\n            .filterMap(([name, codepoint]) => {\n                const glyph = ufont.glyphByCodepoint(codepoint);\n                if (glyph) {\n                    return [name, new Icon(this, name, codepoint, glyph)] as const;\n                }\n            })\n            .collectMap();\n\n        this.family = family;\n        this.ufont = ufont;\n        this.icons = icons;\n    }\n\n    // Create and register font from description\n    static async load(fontDesc: { name: string; metadata: string; font: string }): Promise<Font> {\n        const [metadata, fontData] = await Promise.all([\n            fetch(fontDesc.metadata).then((r) => r.json()),\n            fetch(fontDesc.font).then((r) => r.arrayBuffer()),\n        ]);\n\n        // register font\n        document.fonts.add(new FontFace(fontDesc.name, fontData));\n\n        // create style\n        const style = document.createElement(\"style\");\n        style.innerText = `.${fontDesc.name} {font-family: \"${fontDesc.name}\"}`;\n        document.getElementsByTagName(\"head\")[0]!.appendChild(style);\n\n        const font = new UFont(fontData);\n        return new Font(fontDesc.name, font, metadata.names);\n    }\n\n    getIcon(name: string): Icon | undefined {\n        return this.icons.get(name);\n    }\n}\n\nclass Icon {\n    font: Font;\n    glyph: UGlyph;\n    name: string;\n    codepoint: number;\n    content: string;\n\n    constructor(font: Font, name: string, codepoint: number, uglyph: UGlyph) {\n        this.font = font;\n        this.glyph = uglyph;\n        this.name = name;\n        this.codepoint = codepoint;\n        this.content = String.fromCodePoint(this.codepoint);\n    }\n\n    get fullName(): string {\n        return `${this.font.family}-${this.name}`;\n    }\n\n    toSVGString(): string {\n        const [svgPath, _bbox] = this.glyph.toSVGPath();\n        return [\n            '<?xml version=\"1.0\"?>',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">',\n            `  <path d=\"${svgPath}\"/>`,\n            \"</svg>\",\n        ].join(\"\\n\");\n    }\n\n    toHTMLElement(): HTMLDivElement {\n        const div = document.createElement(\"div\");\n        div.textContent = this.content;\n        div.style.fontFamily = this.font.family;\n        div.classList.add(\"icon-resolve\");\n        return div;\n    }\n}\n\nexport class IconSet {\n    icons: Map<string, Map<string, Icon>>;\n    size: number;\n\n    constructor(icons: Map<string, Map<string, Icon>>) {\n        this.icons = icons;\n        this.size = new Iter(icons.values()).fold(0, (size, nameToIcon) => size + nameToIcon.size);\n    }\n\n    static fromFonts(fonts: Iterable<Font>) {\n        const icons = new Iter(fonts)\n            .map((font) => [font.family, font.icons] as const)\n            .collectMap();\n        return new IconSet(icons);\n    }\n\n    // Create new IconSet only containing icons with names matching selector\n    filter(selector: string): IconSet {\n        if (selector.length == 0) {\n            return this;\n        }\n        const regex = new RegExp(selector);\n        const icons = new Iter(this.icons)\n            .filterMap(([fontFamily, icons]) => {\n                const iconsFiltered = new Iter(icons)\n                    .filter(([iconName, icon]) => {\n                        return iconName.search(regex) >= 0;\n                    })\n                    .collectMap();\n                return iconsFiltered.size == 0\n                    ? null\n                    : ([fontFamily, iconsFiltered] as [string, Map<string, Icon>]);\n            })\n            .collectMap();\n        return new IconSet(icons);\n    }\n\n    find(iconFullName: string): Icon | null {\n        const match = iconFullName.match(/(?<fontFamily>[^-]*)-(?<iconName>.*)/);\n        if (!match) {\n            return null;\n        }\n        const { fontFamily, iconName } = match.groups!;\n        return this.icons.get(fontFamily!)?.get(iconName!) ?? null;\n    }\n\n    toHTMLElement(ctx: {\n        sectionsExpanded: Map<string, boolean>;\n        iconUI: { fold: Icon; unfold: Icon };\n    }): HTMLDivElement {\n        const sections = document.createElement(\"div\");\n        sections.classList.add(\"sections\");\n        new Iter(this.icons).forEach(([fontName, names]) => {\n            // section\n            const section = document.createElement(\"div\");\n            section.classList.add(\"section\");\n            sections.appendChild(section);\n\n            // header\n            const sectionHeader = document.createElement(\"div\");\n            sectionHeader.appendChild(\n                (ctx.sectionsExpanded.get(fontName)\n                    ? ctx.iconUI.fold\n                    : ctx.iconUI.unfold\n                ).toHTMLElement()\n            );\n            const fontNameCapital = fontName.charAt(0).toUpperCase() + fontName.slice(1);\n            sectionHeader.appendChild(\n                document.createTextNode(`${fontNameCapital} (${names.size})`)\n            );\n            sectionHeader.classList.add(\"section-header\");\n            sectionHeader.addEventListener(\"click\", (event) => {\n                if (ctx.sectionsExpanded.get(fontName)) {\n                    ctx.sectionsExpanded.set(fontName, false);\n                    sectionIcons.style.display = \"none\";\n                    sectionHeader.replaceChild(\n                        ctx.iconUI.unfold.toHTMLElement(),\n                        sectionHeader.firstChild!\n                    );\n                } else {\n                    ctx.sectionsExpanded.set(fontName, true);\n                    sectionIcons.style.display = \"\";\n                    sectionHeader.replaceChild(\n                        ctx.iconUI.fold.toHTMLElement(),\n                        sectionHeader.firstChild!\n                    );\n                }\n            });\n            section.appendChild(sectionHeader);\n\n            // icons\n            const headerIconName = document.getElementById(\"header-icon-name\")!;\n            const sectionIcons = document.createElement(\"div\");\n            sectionIcons.classList.add(\"section-icons\");\n            sectionIcons.classList.add(fontName);\n            sectionIcons.style.display = ctx.sectionsExpanded.get(fontName) ? \"\" : \"none\";\n            new Iter(names).forEach(([name, icon]) => {\n                const iconElement = document.createElement(\"div\");\n                const iconName = `${fontName}-${name}`;\n                iconElement.textContent = icon.content;\n                iconElement.dataset.name = iconName;\n                iconElement.addEventListener(\"click\", () => previewShow(icon));\n                iconElement.addEventListener(\"mouseover\", (event) => {\n                    const target = event.target as HTMLDivElement;\n                    headerIconName.innerText = target.dataset.name!;\n                });\n                iconElement.addEventListener(\"mouseleave\", (event) => {\n                    headerIconName.innerText = \"\";\n                });\n                sectionIcons.appendChild(iconElement);\n            });\n            section.appendChild(sectionIcons);\n        });\n        return sections;\n    }\n}\n\nfunction debounce<A extends any[]>(\n    this: any,\n    func: (...args: A) => void,\n    timeout: number = 300\n): (...args: A) => void {\n    let timer: number;\n    return (...args) => {\n        clearTimeout(timer);\n        timer = window.setTimeout(() => {\n            func.apply(this, args);\n        }, timeout);\n    };\n}\n\nfunction previewShow(icon: Icon): void {\n    const previewSVG = document.getElementById(\"preview-svg\")!;\n    previewSVG.innerHTML = icon.toSVGString();\n\n    const previewName = document.getElementById(\"preview-name\")!;\n    const hexCodepoint = icon.codepoint.toString(16).toUpperCase();\n    previewName.innerHTML = `${icon.fullName} <span class=\"codepoint\">U+${hexCodepoint}<span>`;\n\n    const previewDialog = document.getElementById(\"preview-dialog\") as HTMLDialogElement;\n    previewDialog.dataset.name = icon.fullName;\n    previewDialog.showModal();\n}\n\nexport function setup(iconSet: IconSet) {\n    // setup context\n    const iconUI = {\n        close: iconSet.find(\"material-close-circle-outline\")!,\n        clipboard: iconSet.find(\"material-clipboard-outline\")!,\n        copySVG: iconSet.find(\"material-vector-curve\")!,\n        fold: iconSet.find(\"material-minus-box-outline\")!,\n        foldAll: iconSet.find(\"material-collapse-all-outline\")!,\n        unfold: iconSet.find(\"material-plus-box-outline\")!,\n        unfoldAll: iconSet.find(\"material-expand-all-outline\")!,\n        theme: iconSet.find(\"material-theme-light-dark\")!,\n    };\n    const sectionsExpanded = new Iter(iconSet.icons.keys())\n        .map((name) => [name, true] as [string, boolean])\n        .collectMap();\n    const ctx = { iconUI, sectionsExpanded };\n\n    // preview dialog\n    const previewDialog = document.getElementById(\"preview-dialog\") as HTMLDialogElement;\n    previewDialog.addEventListener(\"click\", (event) => {\n        const dialogDims = previewDialog.getBoundingClientRect();\n        if (\n            event.clientX < dialogDims.left ||\n            event.clientX > dialogDims.right ||\n            event.clientY < dialogDims.top ||\n            event.clientX > dialogDims.bottom\n        ) {\n            previewDialog.close();\n        }\n    });\n    const previewClose = document.getElementById(\"preview-close\") as HTMLButtonElement;\n    previewClose.replaceChildren(ctx.iconUI.close.toHTMLElement());\n    previewClose.addEventListener(\"click\", () => {\n        previewDialog.close();\n    });\n    const previewCopyName = document.getElementById(\"preview-copy-name\") as HTMLButtonElement;\n    previewCopyName.replaceChildren(ctx.iconUI.clipboard.toHTMLElement());\n    previewCopyName.addEventListener(\"click\", () => {\n        navigator.clipboard.writeText(previewDialog.dataset.name!);\n    });\n    const previewCopySVG = document.getElementById(\"preview-copy-svg\") as HTMLButtonElement;\n    previewCopySVG.replaceChildren(ctx.iconUI.copySVG.toHTMLElement());\n    previewCopySVG.addEventListener(\"click\", () => {\n        let icon = iconSet.find(previewDialog.dataset.name!)!;\n        navigator.clipboard.writeText(icon.toSVGString());\n    });\n\n    // search\n    const searchResult = document.getElementById(\"search-result\")!;\n    const searchInput = document.getElementById(\"header-search-input\") as HTMLInputElement;\n    const resultUpdate = () => {\n        let iconSetFilter = iconSet.filter(searchInput.value).toHTMLElement(ctx);\n        searchResult.replaceChildren(iconSetFilter);\n    };\n    searchInput.addEventListener(\"input\", debounce(resultUpdate));\n\n    // expand/collapse\n    const collapse = document.getElementById(\"collapse\")!;\n    collapse.appendChild(ctx.iconUI.foldAll.toHTMLElement());\n    collapse.addEventListener(\"click\", () => {\n        const hide = new Iter(ctx.sectionsExpanded.values()).fold(\n            false,\n            (acc, item) => acc || item\n        );\n        for (const name of ctx.sectionsExpanded.keys()) {\n            ctx.sectionsExpanded.set(name, !hide);\n        }\n        collapse.replaceChildren(\n            (hide ? ctx.iconUI.unfoldAll : ctx.iconUI.foldAll).toHTMLElement()\n        );\n        resultUpdate();\n    });\n\n    // Light/Dark theme button\n    const themeToggleButton = document.getElementById(\"theme-button\") as HTMLButtonElement;\n    themeToggleButton.replaceChildren(ctx.iconUI.theme.toHTMLElement());\n    themeToggleButton.addEventListener(\"click\", () => {\n        // apply theme without search results as it is much faster\n        searchResult.replaceChildren();\n        localStorage.setItem(\n            \"theme-dark\",\n            document.documentElement.classList.toggle(\"theme-dark\").toString()\n        );\n        resultUpdate();\n    });\n\n    resultUpdate();\n}\n"
  ],
  "mappings": "AAAO,MAAM,CAAQ,CACjB,KAEA,WAAW,CAAC,EAAuB,CAC/B,KAAK,KAAO,EAAS,OAAO,UAAU,GAGzC,OAAO,SAAS,EAAgB,CAC7B,OAAO,KAAK,KAGhB,IAAI,EAAsB,CACtB,OAAO,KAAK,KAAK,KAAK,QAGnB,KAAO,CAAC,EAA4B,CACvC,OAAO,IAAI,EAAK,CAAI,QAGjB,MAAK,CAAC,EAAe,EAAe,EAAe,EAAiB,CACvE,SAAU,CAAQ,EAAG,CACjB,GAAI,IAAS,OACT,EAAO,EACP,EAAQ,EAEZ,QAAS,EAAI,EAAO,EAAO,EAAI,EAAI,EAAO,EAAI,EAAM,GAAK,EACrD,MAAM,EAGd,OAAO,IAAI,EAAK,EAAS,CAAC,QAGvB,IAAwB,IAAI,EAAwC,CACvE,IAAM,EAAQ,EAAU,IAAI,CAAC,IAAS,EAAK,OAAO,UAAU,CAAC,EACvD,EAAY,EAAU,OAC5B,SAAU,CAAM,EAAG,CACf,MAAO,GAAM,CACT,IAAI,EAAO,CAAC,EACZ,QAAS,EAAY,EAAG,EAAY,EAAW,IAAa,CACxD,IAAM,EAAa,EAAM,GAAY,KAAK,EAC1C,GAAI,EAAW,KACX,OAEJ,EAAK,KAAK,EAAW,KAAK,EAE9B,MAAM,GAGd,OAAO,IAAI,EAAK,EAAO,CAAC,EAG5B,GAAM,CAAC,EAA2C,CAC9C,OAAO,KAAK,oBAAqB,CAAM,CAAC,EAAM,CAC1C,IAAM,EAAW,EAAK,OAAO,UAAU,EACjC,EAAY,EAAM,OAAO,UAAU,EACzC,MAAO,GAAM,CACT,IAAI,EAAW,EAAS,KAAK,EACzB,EAAY,EAAU,KAAK,EAC/B,GAAI,EAAS,MAAQ,EAAU,KAC3B,OAEJ,KAAM,CAAC,EAAS,MAAO,EAAU,KAAK,GAE7C,EAGL,SAAS,EAA+B,CACpC,OAAO,KAAK,oBAAqB,CAAY,CAAC,EAAM,CAChD,IAAI,EAAQ,EACZ,QAAS,KAAQ,EACb,KAAM,CAAC,EAAO,CAAI,EAClB,GAAS,EAEhB,EAGL,GAAM,CAAC,EAAgC,CACnC,OAAO,KAAK,oBAAqB,CAAM,CAAC,EAAM,CAC1C,QAAS,KAAQ,EACb,MAAM,EAAM,CAAI,EAEvB,EAGL,MAAM,CAAC,EAAuC,CAC1C,OAAO,KAAK,oBAAqB,CAAS,CAAC,EAAM,CAC7C,QAAS,KAAQ,EACb,GAAI,EAAO,CAAI,EACX,MAAM,EAGjB,EAGL,SAAY,CAAC,EAAmD,CAC5D,OAAO,KAAK,oBAAqB,CAAY,CAAC,EAAM,CAChD,QAAS,KAAa,EAAM,CACxB,IAAM,EAAY,EAAY,CAAS,EACvC,GAAI,EACA,MAAM,GAGjB,EAGL,OAAU,CAAC,EAA8C,CACrD,OAAO,KAAK,oBAAqB,CAAU,CAAC,EAAM,CAC9C,QAAS,KAAa,EAAM,CACxB,IAAI,EAAa,EAAU,CAAS,EACpC,GAAI,EACA,QAAS,KAAa,EAClB,MAAM,GAIrB,EAGL,OAAO,CAAC,EAAoC,CACxC,QAAS,KAAQ,KACb,EAAU,CAAI,EAItB,IAAO,CAAC,EAAiB,EAAmC,CACxD,IAAI,EAAM,EACV,QAAS,KAAQ,KACb,EAAM,EAAO,EAAK,CAAI,EAE1B,OAAO,EAGX,YAAY,CAAC,EAA8B,OAAqB,CAC5D,EAAQ,IAAU,OAAY,IAAI,MAAU,EAC5C,QAAW,KAAQ,KACf,EAAM,KAAK,CAAI,EAEnB,OAAO,EAGX,UAAU,CAAC,EAA0B,OAAmB,CACpD,EAAM,IAAQ,OAAY,IAAI,IAAQ,EACtC,QAAW,KAAQ,KACf,EAAI,IAAI,CAAI,EAEhB,OAAO,EAGX,UAAgB,CAEZ,EAA6B,OACpB,CACT,EAAM,IAAQ,OAAY,IAAI,IAAQ,EACtC,QAAY,EAAK,KAAU,KACvB,EAAI,IAAI,EAAK,CAAK,EAEtB,OAAO,EAGX,aAAgB,EAEd,CACE,OAAO,OAAO,YAAY,IAAI,EAG1B,UAAa,CAAC,EAAoD,CACtE,OAAO,IAAI,EAAK,EAAM,IAAI,CAAC,EAEnC,CC9JO,MAAM,CAA4C,CACrD,GACA,GACA,GACA,GACA,GAEA,WAAW,CACP,EAAoB,GACpB,EAA2B,KAC3B,EAAuB,KACzB,CACE,KAAK,GAAU,CAAC,EAChB,KAAK,GAAY,EACjB,KAAK,GAAM,GAAM,EAAU,SAAS,EACpC,KAAK,GAAa,KAClB,KAAK,GAAmB,IAAI,KAAK,aAAa,QAAS,CACnD,YAAa,GACb,sBAAuB,GAAa,CACxC,CAAC,EAGL,EAAW,CAAC,EAAU,EAAqB,CACvC,EAAI,KAAK,GAAI,MAAM,CAAC,EACpB,IAAM,EAAK,KAAK,IAAa,KAAK,GAAa,EAAE,IAAI,KAAK,EAAU,EAAI,EAExE,GAAI,GAAO,EAAG,GAAK,EACf,KAAK,GAAQ,KAAK,GAAG,EAGzB,GADA,KAAK,GAAQ,KAAK,KAAK,GAAiB,OAAO,EAAG,CAAC,CAAC,EAChD,EAAG,GAAK,EACR,KAAK,GAAQ,KAAK,GAAG,EAGzB,OADA,KAAK,GAAQ,KAAK,KAAK,GAAiB,OAAO,EAAG,CAAC,CAAC,EAC7C,EAGX,MAAM,CAAC,EAAgB,CACnB,KAAK,GAAQ,KAAK,KAAK,IAAa,KAAK,GAAa,IAAM,GAAG,EAC/D,KAAK,GAAa,KAAK,GAAY,EAAG,EAAK,EAG/C,MAAM,CAAC,EAAgB,CACnB,KAAK,GAAQ,KAAK,KAAK,GAAY,IAAM,GAAG,EAC5C,KAAK,GAAa,KAAK,GAAY,EAAG,EAAK,EAG/C,MAAM,CAAC,EAAW,EAAiB,CAC/B,KAAK,GAAQ,KAAK,KAAK,GAAY,IAAM,GAAG,EAC5C,KAAK,GAAY,EAAI,EAAK,EAC1B,KAAK,GAAa,KAAK,GAAY,EAAI,EAAI,EAG/C,OAAO,CAAC,EAAW,EAAW,EAAiB,CAC3C,KAAK,GAAQ,KAAK,KAAK,GAAY,IAAM,GAAG,EAC5C,KAAK,GAAY,EAAI,EAAK,EAC1B,KAAK,GAAY,EAAI,EAAI,EACzB,KAAK,GAAa,KAAK,GAAY,EAAI,EAAI,EAG/C,KAAK,EAAS,CACV,KAAK,GAAQ,KAAK,GAAG,EAGzB,KAAK,EAAW,CACZ,OAAO,KAAK,GAAQ,KAAK,EAAE,EAEnC,CAEA,MAAM,CAAsC,CACrB,IAAiC,IAApD,WAAW,CAAQ,EAAoB,KAAa,EAAoB,KAAM,CAA3D,WAAiC,WAEpD,MAAM,CAAC,EAAgB,CACnB,GAAI,KAAK,MAAQ,MAAQ,KAAK,MAAQ,KAAM,CACxC,KAAK,IAAM,IAAI,EAAM,EAAE,EAAG,EAAE,CAAC,EAC7B,KAAK,IAAM,IAAI,EAAM,EAAE,EAAG,EAAE,CAAC,EAC7B,OAEJ,GAAI,EAAE,EAAI,KAAK,IAAI,EACf,KAAK,IAAI,EAAI,EAAE,EAEnB,GAAI,EAAE,EAAI,KAAK,IAAI,EACf,KAAK,IAAI,EAAI,EAAE,EAEnB,GAAI,EAAE,EAAI,KAAK,IAAI,EACf,KAAK,IAAI,EAAI,EAAE,EAEnB,GAAI,EAAE,EAAI,KAAK,IAAI,EACf,KAAK,IAAI,EAAI,EAAE,EAIvB,MAAM,CAAC,EAAgB,CACnB,KAAK,OAAO,CAAC,EAGjB,MAAM,CAAC,EAAgB,CACnB,KAAK,OAAO,CAAC,EAGjB,MAAM,CAAC,EAAW,EAAiB,CAC/B,KAAK,OAAO,CAAE,EACd,KAAK,OAAO,CAAE,EAGlB,OAAO,CAAC,EAAW,EAAW,EAAiB,CAC3C,KAAK,OAAO,CAAE,EACd,KAAK,OAAO,CAAE,EACd,KAAK,OAAO,CAAE,EAGlB,KAAK,EAAS,EAClB,CAEO,MAAM,CAAM,CACI,EAAkB,EAArC,WAAW,CAAQ,EAAkB,EAAW,CAA7B,SAAkB,SACrC,GAAG,CAAC,EAAqB,CACrB,OAAO,IAAI,EAAM,KAAK,EAAI,EAAM,EAAG,KAAK,EAAI,EAAM,CAAC,EAEvD,GAAG,CAAC,EAAqB,CACrB,OAAO,IAAI,EAAM,KAAK,EAAI,EAAM,EAAG,KAAK,EAAI,EAAM,CAAC,EAEvD,GAAG,CAAC,EAAuB,CACvB,OAAO,IAAI,EAAM,KAAK,EAAI,EAAQ,KAAK,EAAI,CAAM,EAErD,IAAI,CAAC,EAAc,EAA2B,CAC1C,IAAM,EAAY,EAAM,EACxB,OAAO,IAAI,EACP,KAAK,EAAI,EAAY,EAAM,EAAI,EAC/B,KAAK,EAAI,EAAY,EAAM,EAAI,CACnC,EAEJ,QAAQ,EAAW,CACf,MAAO,SAAS,KAAK,MAAM,KAAK,KAExC,CAEO,MAAM,CAAU,CAER,IACA,IACA,IACA,IACA,IACA,IANX,WAAW,CACA,EACA,EACA,EACA,EACA,EACA,EACT,CANS,WACA,WACA,WACA,WACA,WACA,iBAEJ,SAAQ,EAAc,CACzB,OAAO,IAAI,EAAU,EAAK,EAAK,EAAK,EAAK,EAAK,CAAG,EAErD,SAAS,CAAC,EAAY,EAAuB,CACzC,OAAO,KAAK,OAAO,IAAI,EAAU,EAAK,EAAK,EAAI,EAAK,EAAK,CAAE,CAAC,EAEhE,KAAK,CAAC,EAAY,EAAuB,CACrC,OAAO,KAAK,OAAO,IAAI,EAAU,EAAI,EAAK,EAAK,EAAK,EAAI,CAAG,CAAC,EAEhE,MAAM,CAAC,EAA0B,CAC7B,IAAM,EAAM,KAAK,IAAI,CAAK,EACpB,EAAM,KAAK,IAAI,CAAK,EAC1B,OAAO,KAAK,OAAO,IAAI,EAAU,GAAM,EAAK,EAAK,EAAK,EAAK,CAAG,CAAC,EAEnE,MAAM,CAAC,EAA6B,CAChC,OAAO,IAAI,EACP,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IACxC,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IACxC,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IAAM,KAAK,IACnD,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IACxC,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IACxC,KAAK,IAAM,EAAM,IAAM,KAAK,IAAM,EAAM,IAAM,KAAK,GACvD,EAEJ,KAAK,CAAC,EAAqB,CACvB,OAAO,IAAI,EACP,EAAM,EAAI,KAAK,IAAM,EAAM,EAAI,KAAK,IAAM,KAAK,IAC/C,EAAM,EAAI,KAAK,IAAM,EAAM,EAAI,KAAK,IAAM,KAAK,GACnD,EAER,CAQA,IAAM,EAAiB,EACjB,EAAiB,EACjB,EAAiB,EACjB,EAAc,EACd,EAAgB,GAChB,EAAgB,GAEhB,EAAwB,EACxB,EAAqB,EACrB,EAAkB,EAClB,EAAkB,GAClB,EAA2B,GAC3B,EAAuB,IAEtB,MAAM,CAAM,CACf,KACA,QACA,cACA,SACA,SACA,GAEA,WAAW,CAAC,EAAY,EAAiB,EAAuB,CAI5D,GAHA,KAAK,KAAO,EACZ,KAAK,QAAU,EAEX,GAAU,EAAO,OAAO,IAAM,EAC9B,KAAK,cAAgB,EAAO,QAAQ,EACpC,KAAK,SAAW,IAAI,EAAM,EAAO,QAAQ,EAAG,EAAO,QAAQ,CAAC,EAC5D,KAAK,SAAW,IAAI,EAAM,EAAO,QAAQ,EAAG,EAAO,QAAQ,CAAC,EAC5D,KAAK,GAAU,EAAO,KAAK,EAAE,MAE7B,MAAK,cAAgB,EACrB,KAAK,SAAW,IAAI,EAAM,EAAG,CAAC,EAC9B,KAAK,SAAW,IAAI,EAAM,EAAG,CAAC,EAC9B,KAAK,GAAU,KAIvB,QAAQ,EAAW,CACf,IAAQ,EAAG,EAAO,EAAG,GAAW,KAAK,SAAS,IAAI,KAAK,QAAQ,EACzD,EAAa,KAAK,GAAU,KAAK,GAAQ,OAAO,EAAI,EAC1D,MAAO,cAAc,CAAC,EAAO,CAAM,UAAU,KAAK,sBAC9C,KAAK,uBACC,KAId,SAAS,CACL,EAAuB,KACvB,EAAoB,GACpB,EAA2B,KACI,CAC/B,IAAM,EAAO,KAAK,KAAK,EACvB,GAAI,IAAS,KACT,MAAO,CAAC,GAAI,IAAI,EAIpB,IAAO,EAAK,GAAO,EACb,EAAM,EAAI,IAAI,CAAG,EAAE,IAAI,GAAG,EAC1B,EAAK,KAAK,IACZ,KAAK,KAAK,aAAa,EAAE,YACxB,EAAI,EAAI,EAAI,GAAK,KACjB,EAAI,EAAI,EAAI,GAAK,GACtB,EACM,EAAS,IAAI,EAAM,EAAK,EAAG,EAAK,CAAC,EAAE,IAAI,CAAG,EAUhD,OARA,EAAK,GAAM,EAAU,SAAS,EAC9B,EAAK,EAAG,OACJ,IAAI,EAAU,EAAG,EAAG,EAAG,EAAG,GAAI,GAAG,EAC5B,MAAM,IAAM,EAAI,IAAM,CAAE,EACxB,UAAU,EAAO,EAAG,EAAO,CAAC,CACrC,EAGO,CADS,KAAK,aAAa,IAAI,EAAkB,EAAU,EAAW,CAAE,CAAC,EAAE,MAAM,EACvE,CAAI,EAQzB,IAAI,EAA0B,CAC1B,GAAI,KAAK,cAAgB,EAAG,CACxB,IAAM,EAAO,KAAK,aAAa,IAAI,CAAa,EAChD,GAAI,EAAK,MAAQ,MAAQ,EAAK,MAAQ,KAClC,OAAO,KAEX,MAAO,CAAC,EAAK,IAAK,EAAK,GAAG,UACnB,KAAK,gBAAkB,EAC9B,OAAO,SACJ,CACH,IAAM,EAAO,EAAK,KAAK,KAAK,GAAqB,CAAC,EAAE,KAChD,IAAI,EACJ,CAAC,EAAM,IAAU,CAEb,OADA,EAAK,OAAO,EAAM,KAAK,EAChB,EAEf,EACA,GAAI,EAAK,MAAQ,MAAQ,EAAK,MAAQ,KAClC,OAAO,KAEX,MAAO,CAAC,EAAK,IAAK,EAAK,GAAG,GAKlC,YAAsC,CAAC,EAAY,EAAuB,KAAS,CAC/E,GAAI,KAAK,eAAiB,EACtB,KAAK,GAAoB,EAAS,CAAE,MAEpC,MAAK,GAAuB,EAAS,CAAE,EAE3C,OAAO,EAWX,EAAmB,CAAC,EAAyB,EAA4B,CACrE,EAAK,GAAM,EAAU,SAAS,EAC9B,IAAI,EAA6B,KAC7B,EAA8B,KAC9B,EAA6B,KACjC,QAAW,KAAS,KAAK,GAAqB,EAAG,CAC7C,GAAI,IAAiB,KACjB,GAAI,EAAM,UACN,EAAe,EAAM,MACrB,EAAQ,OAAO,EAAG,MAAM,EAAM,KAAK,CAAC,UAEhC,EAAe,CACf,IAAM,EAAM,EAAc,KAAK,EAAM,MAAO,GAAG,EAC/C,EAAe,EACf,EAAe,EAAM,MACrB,EAAQ,OAAO,EAAG,MAAM,CAAG,CAAC,MAE5B,GAAgB,EAAM,cAI1B,EACA,GAAI,EAAM,UACN,EAAQ,OAAO,EAAG,MAAM,CAAY,EAAG,EAAG,MAAM,EAAM,KAAK,CAAC,EAC5D,EAAe,SACZ,CACH,IAAM,EAAM,EAAa,KAAK,EAAM,MAAO,GAAG,EAC9C,EAAQ,OAAO,EAAG,MAAM,CAAY,EAAG,EAAG,MAAM,CAAG,CAAC,EACpD,EAAe,EAAM,cAGrB,EAAM,UACN,EAAQ,OAAO,EAAG,MAAM,EAAM,KAAK,CAAC,MAEpC,GAAe,EAAM,MAKjC,GAAI,EAAM,OAAQ,CACd,GAAI,GAAiB,EAAc,CAC/B,IAAM,EAAM,EAAa,KAAK,EAAe,GAAG,EAChD,EAAQ,OAAO,EAAG,MAAM,CAAY,EAAG,EAAG,MAAM,CAAG,CAAC,EACpD,EAAe,KAEnB,GAAI,EACA,GAAI,EACA,EAAQ,OAAO,EAAG,MAAM,CAAa,EAAG,EAAG,MAAM,CAAY,CAAC,UACvD,EACP,EAAQ,OAAO,EAAG,MAAM,CAAY,EAAG,EAAG,MAAM,CAAY,CAAC,MAE7D,GAAQ,OAAO,EAAG,MAAM,CAAY,CAAC,EAG7C,EAAQ,MAAM,EACd,EAAe,KACf,EAAgB,KAChB,EAAe,OAW3B,YAAiC,EAAqC,CAClE,GAAI,KAAK,eAAiB,EACtB,OAGJ,IAAM,EAAS,KAAK,GACpB,EAAO,KAAK,CAAC,EAEb,IAAI,EAAc,EACZ,EAAY,EAAK,MAAM,KAAK,aAAa,EAC1C,IAAI,CAAC,IAAM,CACR,IAAI,EAAQ,EAAO,QAAQ,EAE3B,OADA,EAAc,EACP,EACV,EACA,WAAW,EAIhB,GAHA,EAAc,EAAc,EAGxB,GAAe,EACf,OAIJ,IAAM,EAAkB,EAAO,QAAQ,EACvC,EAAO,QAAQ,CAAe,EAE9B,IAAI,EAAO,EACP,EAAO,EACP,EAAY,EACZ,EAAkB,CAAC,EACvB,MAAO,EAAY,EAAG,CAClB,IAAM,EAAO,EAAO,OAAO,EAEvB,EAAU,EAEd,GADA,EAAM,KAAK,CAAI,EACX,EAAO,EAAa,CACpB,GAAW,EAAO,OAAO,EACzB,QAAW,KAAK,EAAK,MAAM,EAAU,CAAC,EAClC,EAAM,KAAK,CAAI,EAGvB,GAAI,EAAU,EACV,MAIJ,GAFA,GAAa,EAET,EAAO,EACP,GAAQ,YACC,EAAO,GAChB,GAAQ,EAAU,EAEtB,GAAI,EAAO,EACP,GAAQ,YACC,EAAO,GAChB,GAAQ,EAAU,EAK1B,IAAM,EAAS,EAAO,KAAK,EACvB,EAAS,EAAS,EAClB,EAAO,EAAS,EACd,EAAW,EAAO,KAAK,EAAQ,CAAM,EACrC,EAAU,EAAO,KAAK,EAAQ,CAAI,EAGpC,EAAI,EACJ,EAAI,EACR,QAAY,EAAO,KAAS,EAAK,KAAK,CAAK,EAAE,UAAU,EAAG,CACtD,IAAI,EAAQ,EACN,IAAkB,EAAO,GAC/B,GAAI,EAAO,GAEP,GADA,EAAQ,EAAS,OAAO,EACpB,EACA,GAAS,UAEN,EACP,EAAQ,EAAS,QAAQ,EAE7B,GAAK,EAEL,IAAI,EAAQ,EACN,IAAkB,EAAO,GAC/B,GAAI,EAAO,GAEP,GADA,EAAQ,EAAQ,OAAO,EACnB,EACA,GAAS,UAEN,EACP,EAAQ,EAAQ,QAAQ,EAE5B,GAAK,EAEL,KAAM,CACF,MAAO,IAAI,EAAM,EAAG,CAAC,EACrB,UAAW,QAAQ,EAAO,CAAc,EACxC,OAAQ,EAAU,IAAI,CAAK,CAC/B,IAIR,EAAsB,CAAC,EAAyB,EAA4B,CACxE,EAAK,GAAM,EAAU,SAAS,EAE9B,IAAM,EAAS,KAAK,GACpB,EAAO,KAAK,CAAC,EAEb,IAAM,EAAY,KAAK,KAAK,aAAa,EACzC,MAAO,GAAM,CACT,IAAM,EAAO,EAAO,QAAQ,EAGtB,EAAU,EAAO,QAAQ,EACzB,EAAQ,EAAU,OAAO,GAAG,CAAO,EACzC,GAAI,IAAU,OAAW,CAMrB,GALA,QAAQ,MACJ,IAAI,KAAK,KAAK,aAAa,EAAE,WACzB,KAAK,oCACoB,GACjC,IACM,EAAO,GACT,MAEJ,SAGJ,IAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACtD,GAAI,EAAO,EACP,GAAI,EAAO,EACP,EAAM,EAAO,QAAQ,EACrB,EAAM,EAAO,QAAQ,MAErB,GAAM,EAAO,OAAO,EACpB,EAAM,EAAO,OAAO,EAG5B,GAAI,EAAO,EACP,EAAM,EAAO,YAAY,EACzB,EAAM,EAAO,YAAY,EACzB,EAAM,EAAO,YAAY,EACzB,EAAM,EAAO,YAAY,UAClB,EAAO,EACd,EAAM,EAAO,YAAY,EACzB,EAAM,EAAO,YAAY,UAClB,EAAO,EACd,EAAM,EAAO,YAAY,EACzB,EAAM,EAEV,IAAM,EAAK,IAAI,EAAU,EAAK,EAAK,EAAK,EAAK,EAAK,CAAG,EAKrD,GAFA,EAAM,aAAa,EAAS,EAAG,OAAO,CAAE,CAAC,IAEnC,EAAO,GACT,OAIhB,CAEO,MAAM,CAAO,CAChB,GACA,GAEA,WAAW,CAAC,EAAgB,CACxB,KAAK,GAAQ,EACb,KAAK,GAAY,EAGrB,IAAI,EAAgB,CAChB,IAAM,EAAS,KAAK,GAAM,WAC1B,OAAO,KAAK,GAAM,OAAO,MAAM,EAAQ,EAAS,KAAK,GAAM,UAAU,EAGzE,MAAM,EAAW,CACb,OAAO,KAAK,GAAM,WAGtB,IAAI,EAAW,CACX,OAAO,KAAK,GAGhB,IAAI,CAAC,EAAa,EAAoB,GAAc,CAChD,IAAK,EACD,KAAK,IAAa,UACX,GAAO,EACd,KAAK,GAAY,UACV,EAAM,EACb,KAAK,GAAY,KAAK,GAAM,WAAa,EAE7C,OAAO,KAAK,QAAQ,CAAC,EAGzB,OAAO,CAAC,EAAsB,CAC1B,IAAM,EAAW,KAAK,GAAY,EAElC,OADA,KAAK,GAAY,KAAK,IAAI,EAAG,KAAK,IAAI,EAAU,KAAK,GAAM,UAAU,CAAC,EAC/D,KAAK,GAGhB,IAAI,CAAC,EAAuB,EAAG,EAAqB,KAAc,CAC9D,GAAI,IAAU,KACV,EAAQ,KAAK,OAEb,GAAQ,KAAK,IAAI,EAAG,KAAK,IAAI,EAAO,KAAK,GAAM,UAAU,CAAC,EAE9D,GAAI,IAAQ,KACR,EAAM,KAAK,GAAM,eAEjB,GAAM,KAAK,IAAI,EAAO,KAAK,IAAI,EAAK,KAAK,GAAM,UAAU,CAAC,EAE9D,IAAM,EAAO,IAAI,SAAS,KAAK,GAAM,OAAQ,KAAK,GAAM,WAAa,EAAO,EAAM,CAAK,EACvF,OAAO,IAAI,EAAO,CAAI,EAG1B,IAAI,CAAC,EAA0B,CAC3B,IAAM,EAAS,IAAI,WACf,KAAK,GAAM,OACX,KAAK,GAAM,WAAa,KAAK,GAC7B,CACJ,EAEA,OADA,KAAK,QAAQ,CAAI,EACV,EAGX,UAAU,CAAC,EAAsB,CAE7B,OADgB,IAAI,YAAY,EACjB,OAAO,KAAK,KAAK,CAAI,CAAC,EAGzC,MAAM,EAAW,CACb,IAAM,EAAS,KAAK,GAAM,SAAS,KAAK,EAAS,EAEjD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,MAAM,EAAW,CACb,IAAM,EAAS,KAAK,GAAM,QAAQ,KAAK,EAAS,EAEhD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,UAAU,KAAK,EAAS,EAElD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,SAAS,KAAK,EAAS,EAEjD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,UAAU,KAAK,EAAS,EAElD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,SAAS,KAAK,EAAS,EAEjD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,aAAa,KAAK,EAAS,EAErD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,OAAO,EAAW,CACd,IAAM,EAAS,KAAK,GAAM,YAAY,KAAK,EAAS,EAEpD,OADA,KAAK,QAAQ,CAAC,EACP,EAGX,SAAS,EAAW,CAChB,OAAO,KAAK,QAAQ,EAAI,MAG5B,WAAW,EAAW,CAClB,OAAO,KAAK,QAAQ,EAAI,MAG5B,YAAY,EAAS,CACjB,IAAM,EAAY,KAAK,QAAQ,EAAI,YACnC,OAAO,IAAI,KAAK,OAAO,CAAS,EAAI,IAAK,EAG7C,QAAQ,EAAW,CACf,MAAO,kBAAkB,KAAK,YAAmB,KAAK,GAAM,cAEpE,CAEA,MAAM,CAAU,CACO,SAAyB,OAAuB,OAAnE,WAAW,CAAQ,EAAyB,EAAuB,EAAgB,CAAhE,gBAAyB,cAAuB,cAEnE,MAAM,CAAC,EAAoB,CACvB,OAAO,IAAI,EAAO,IAAI,SAAS,EAAK,KAAM,KAAK,OAAQ,KAAK,MAAM,CAAC,EAE3E,CAKA,IAAM,GAAgB,GAChB,GAAgB,EAChB,GAAgB,GASf,MAAM,CAAK,CACd,GACA,GACA,KACA,SACA,OACA,WAEA,WAAW,CAAC,EAAmB,CAC3B,KAAK,GAAQ,EACb,KAAK,OAAS,IAAI,IAClB,KAAK,GAAS,IAAI,IAElB,IAAM,EAAe,IAAI,EAAO,IAAI,SAAS,KAAK,EAAK,CAAC,EAClD,EAAc,EAAa,QAAQ,EACzC,GAAI,IAAgB,MAChB,KAAK,SAAW,cACT,IAAgB,WACvB,KAAK,SAAW,UAEhB,OAAM,IAAI,MAAM,qBAAqB,GAAa,EAEtD,IAAM,EAAY,EAAa,QAAQ,EACvC,EAAa,QAAQ,EACrB,EAAa,QAAQ,EACrB,EAAa,QAAQ,EAGrB,QAAS,EAAQ,EAAG,EAAQ,EAAW,IAAS,CAC5C,IAAM,EAAM,EAAa,WAAW,CAAC,EACrC,KAAK,OAAO,IACR,EACA,IAAI,EACA,EAAa,QAAQ,EACrB,EAAa,QAAQ,EACrB,EAAa,QAAQ,CACzB,CACJ,EAKJ,IAAM,EAAa,KAAK,OAAO,IAAI,MAAM,EAAG,OAAO,IAAI,EACvD,EAAW,QAAQ,CAAC,EACpB,KAAK,WAAa,EAAW,QAAQ,EAErC,KAAK,KAAO,KAAK,aAAa,KAG9B,KAAI,EAAgB,CACpB,OAAO,KAAK,GAGhB,QAAQ,EAAW,CACf,IAAM,EAAO,KAAK,aAAa,EAC/B,MAAO,eAAe,EAAK,qBAAqB,EAAK,0BAA0B,KAAK,cAIxF,gBAAgB,CAAC,EAAoC,CACjD,GAAI,KAAK,UAAY,MACjB,MAAM,IAAI,MAAM,yCAAyC,EAE7D,IAAM,EAAY,KAAK,aAAa,EACpC,GAAI,IAAc,KACd,OAAO,KAGX,IAAM,EADY,KAAK,aAAa,EACV,mBAAmB,IAAI,CAAS,EAC1D,GAAI,IAAY,OACZ,OAAO,KAEX,OAAO,EAAU,OAAO,GAAG,CAAO,KAIlC,gBAAe,EAA2B,CAE1C,IAAI,EAAkB,KAAK,GAAO,IADhB,iBAC6B,EAC/C,GAAI,IAAoB,OAAW,CAC/B,IAAM,EAAY,KAAK,aAAa,EAC9B,EAAY,KAAK,aAAa,EACpC,EAAkB,IAAI,IACtB,QAAW,KAAW,EAAK,MAAM,KAAK,UAAU,EAAG,CAC/C,IAAM,EAAO,EAAU,cAAc,IAAI,CAAO,EAC1C,EAAY,EAAU,mBAAmB,IAAI,CAAO,EAC1D,GAAI,IAAS,QAAa,IAAc,QAAa,IAAc,EAC/D,SAEJ,EAAgB,IAAI,EAAM,CAAS,EAEvC,KAAK,GAAO,IAdE,kBAca,CAAe,EAE9C,OAAO,EAGX,QAAQ,CACJ,EAAsB,KACtB,EAAyB,KACzB,EAAyB,KACnB,CACN,EAAO,GAAQ,GACf,EAAU,GAAW,GACrB,EAAU,GAAW,GAErB,IAAM,EAAa,KAAK,aAAa,EACrC,GAAI,IAAe,MAAQ,KAAK,aAAe,EAC3C,MAAO,GAGX,IAAM,EAAmB,CAAC,EAG1B,EAAO,KAAK,cAAc,EAE1B,IAAM,EAAQ,EAAO,IACrB,GAAQ,EACR,IAAI,EAAM,EACN,EAAQ,EACZ,QAAW,KAAS,EAAW,OAAQ,CACnC,GAAI,EAAM,gBAAkB,EACxB,SAEJ,EAAM,KAAK,MAAM,EAAQ,CAAO,EAChC,IAAM,EAAM,EAAQ,EACd,EAAK,EAAU,SAAS,EACzB,UAAU,EAAU,EAAM,EAAM,EAAU,EAAM,CAAI,EACpD,MAAM,EAAO,CAAK,GAChB,EAAS,GAAQ,EAAM,UAAU,EAAI,EAAI,EAChD,GAAI,IAAS,KACT,SAEJ,IAAM,EAAW,EAAK,GAAG,IAAI,EAAK,EAAE,EACpC,GAAI,EAAS,IAAM,GAAK,EAAS,IAAM,EACnC,SAEJ,EAAO,KAAK,CAAO,EACnB,EAAO,KAAK;AAAA,CAAI,EAChB,GAAS,EAIb,IAAM,EAAQ,EAAU,EAAU,EAC9B,EAAQ,GAAW,EAAM,GAAK,EAGlC,OAFA,EAAO,KAAK,IAAI,KAAS,WAAe,EAEjC,EAAO,KAAK,EAAE,EAGzB,IAAI,EAAG,CACH,IAAM,EAAY,KAAK,aAAa,EAC9B,EAAY,KAAK,aAAa,EACpC,MAAO,CACH,OAAQ,EAAU,OAClB,UAAW,EAAU,UACrB,QAAS,EAAU,QACnB,YAAa,KAAK,WAClB,WAAY,KAAK,aAAa,EAAE,cAAc,KAC9C,aAAc,EAAU,WACxB,YAAa,EAAU,aAAa,YAAY,EAChD,OAAQ,EAAK,KAAK,KAAK,MAAM,EACxB,IAAI,EAAE,EAAM,KAAW,CAAC,EAAM,EAAM,MAAM,CAAU,EACpD,cAAc,CACvB,EAGJ,EAAY,CAAC,EAAc,EAA8C,CACrE,IAAI,EAAW,KAAK,GAAO,IAAI,CAAI,EACnC,GAAI,IAAU,OAAW,CACrB,IAAM,EAAY,KAAK,OAAO,IAAI,CAAI,EACtC,GAAI,IAAc,OACd,MAAM,IAAI,MAAM,oBAAoB,GAAM,EAE9C,EAAQ,EAAO,KAAM,EAAU,OAAO,IAAI,CAAC,EAC3C,KAAK,GAAO,IAAI,EAAM,CAAK,EAE/B,OAAO,EAGX,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAqB,CAC7B,GAAI,KAAK,OAAO,IAAI,MAAM,IAAM,OAC5B,OAAO,KAEX,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAqB,CAC7B,GAAI,KAAK,OAAO,IAAI,MAAM,IAAM,OAC5B,OAAO,KAEX,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAGhD,YAAY,EAAc,CACtB,OAAO,KAAK,GAAU,OAAQ,EAAU,IAAI,EAEpD,CAMO,MAAM,CAAU,CAER,UACA,OACA,UACA,OACA,SACA,QANX,WAAW,CACA,EACA,EACA,EACA,EACA,EACA,EACT,CANS,iBACA,cACA,iBACA,cACA,gBACA,qBAGJ,KAAI,CAAC,EAAa,EAA2B,CAChD,EAAO,QAAQ,EACf,IAAM,EAAc,EAAO,QAAQ,EAC7B,EAAgB,EAAO,QAAQ,EAW/B,EAAwB,CAAC,EAC/B,QAAS,EAAQ,EAAG,EAAQ,EAAa,IAAS,CAC9C,IAAM,EAAS,CACX,WAAY,EAAO,QAAQ,EAC3B,WAAY,EAAO,QAAQ,EAC3B,WAAY,EAAO,QAAQ,EAC3B,OAAQ,EAAO,QAAQ,EACvB,OAAQ,EAAO,QAAQ,EACvB,OAAQ,EAAO,QAAQ,CAC3B,EACA,GAAI,EAAO,aAAe,EACtB,SAEJ,GAAI,EAAO,aAAe,KACtB,SAEJ,GAAI,EAAO,aAAc,CAAC,EAAG,EAAE,EAC3B,EAAQ,KAAK,CAAM,EAI3B,IAAM,EAA2D,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,EAClF,EAAU,IAAI,YAAY,UAAU,EAC1C,QAAW,KAAU,EAAS,CAC1B,GAAI,EAAO,OAAS,EAChB,SAEJ,EAAO,KAAK,EAAgB,EAAO,MAAM,EACzC,IAAM,EAAQ,EAAO,KAAK,EAAO,MAAM,EACvC,EAAO,EAAO,QAAU,EAAQ,OAAO,CAAK,EAEhD,OAAO,IAAI,EAAU,GAAG,CAAM,EAEtC,CAMO,MAAM,CAAU,CAER,SACA,MACA,WACA,YACA,aACA,SACA,SACA,SACA,cACA,kBACA,iBACA,gBAZX,WAAW,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACT,CAZS,gBACA,aACA,kBACA,mBACA,oBACA,gBACA,gBACA,gBACA,qBACA,yBACA,wBACA,6BAGJ,KAAI,CAAC,EAAa,EAA2B,CAChD,EAAO,QAAQ,EACf,EAAO,QAAQ,EACf,IAAM,EAAe,EAAO,UAAU,EACtC,EAAO,QAAQ,EACf,QAAQ,OAAO,EAAO,QAAQ,IAAM,UAAU,EAC9C,IAAM,EAAQ,EAAO,QAAQ,EACvB,EAAa,EAAO,QAAQ,EAC5B,EAAc,EAAO,aAAa,EAClC,EAAe,EAAO,aAAa,EACnC,EAAW,IAAI,EAAM,EAAO,QAAQ,EAAG,EAAO,QAAQ,CAAC,EACvD,EAAW,IAAI,EAAM,EAAO,QAAQ,EAAG,EAAO,QAAQ,CAAC,EACvD,EAAW,EAAO,QAAQ,EAC1B,EAAgB,EAAO,QAAQ,EAC/B,EAAoB,EAAO,QAAQ,EACnC,EAAmB,EAAO,QAAQ,EAClC,EAAkB,EAAO,QAAQ,EACvC,OAAO,IAAI,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACJ,EAER,CAMO,MAAM,CAAU,CACA,cAAnB,WAAW,CAAQ,EAAqC,CAArC,qBAEnB,QAAQ,EAAW,CACf,MAAO,mBAAmB,KAAK,cAAc,cAG1C,KAAI,CAAC,EAAa,EAA2B,CAEhD,GADgB,EAAO,UAAU,IACjB,EACZ,OAAO,IAAI,EAAU,IAAI,GAAK,EAElC,EAAO,QAAQ,EAAE,EAGjB,IAAM,EAAa,EAAO,QAAQ,EAC5B,EAAuC,IAAI,IAC7C,EAAW,EACf,QAAS,EAAa,EAAG,EAAa,EAAY,IAAc,CAC5D,IAAM,EAAY,EAAO,QAAQ,EACjC,GAAI,EAAY,IAAK,CACjB,IAAM,EAAQ,EAAY,IAC1B,EAAW,KAAK,IAAI,EAAU,CAAK,EACnC,EAAe,IAAI,EAAY,CAAK,GAI5C,IAAM,EAAkB,CAAC,EACnB,EAAa,EAAW,EAC9B,QAAS,EAAK,EAAG,EAAK,EAAY,IAAM,CACpC,IAAM,EAAS,EAAO,OAAO,EAC7B,EAAM,KAAK,EAAO,WAAW,CAAM,CAAC,EAGxC,IAAM,EAAsC,IAAI,IAChD,QAAY,EAAS,KAAU,EAC3B,EAAc,IAAI,EAAS,EAAM,EAAO,EAE5C,OAAO,IAAI,EAAU,CAAa,EAE1C,CAMO,MAAM,CAAU,CAER,mBACA,mBAFX,WAAW,CACA,EACA,EACT,CAFS,0BACA,0BAGX,QAAQ,EAAW,CACf,MAAO,mBAAmB,KAAK,mBAAmB,cAG/C,KAAI,CAAC,EAAa,EAA2B,CAChD,EAAO,QAAQ,EAGf,IAAI,EAAqB,EACnB,EAAY,EAAO,QAAQ,EACjC,QAAS,EAAK,EAAG,EAAK,EAAW,IAAM,CACnC,IAAM,EAAa,EAAO,QAAQ,EAC5B,EAAa,EAAO,QAAQ,EAC5B,EAAiB,EAAO,QAAQ,EACtC,GAAI,IAAe,GAAK,IAAe,EACnC,EAAqB,WACb,GAAsB,IAAe,GAAK,IAAe,EACjE,EAAqB,EAG7B,IAAK,EACD,MAAM,IAAI,MAAM,oDAAoD,EAIxE,EAAO,KAAK,CAAkB,EAC9B,IAAM,EAAiB,EAAO,QAAQ,EAChC,EAAO,IAAI,EAAU,IAAI,IAAO,IAAI,GAAK,EAE/C,GAAI,IAAmB,GAAI,CAEvB,EAAO,QAAQ,EACf,EAAO,QAAQ,EACf,EAAO,QAAQ,EAEf,IAAM,EAAY,EAAO,QAAQ,EACjC,QAAS,EAAK,EAAG,EAAK,EAAW,IAAM,CACnC,IAAM,EAAiB,EAAO,QAAQ,EAChC,EAAe,EAAO,QAAQ,EAAI,EACpC,EAAU,EAAO,QAAQ,EAC7B,QAAS,EAAY,EAAgB,EAAY,EAAc,IAC3D,EAAK,mBAAmB,IAAI,EAAS,CAAS,EAC9C,EAAK,mBAAmB,IAAI,EAAW,CAAO,EAC9C,GAAW,WAGZ,GAAkB,EAAG,CAE5B,IAAM,EAAW,EAAO,QAAQ,EAC1B,EAAW,EAAO,KAAK,EAAO,KAAK,EAAG,EAAO,KAAK,EAAI,CAAQ,EACpE,EAAS,QAAQ,CAAC,EAElB,IAAM,EAAe,KAAK,MAAM,EAAS,QAAQ,EAAI,CAAC,EACtD,EAAS,QAAQ,CAAC,EAClB,IAAM,EAAY,EAAO,QAAQ,EAC3B,EAAW,EAAK,MAAM,CAAY,EACnC,IAAI,CAAC,IAAM,EAAS,QAAQ,CAAC,EAC7B,aAAa,EAClB,EAAS,QAAQ,EACjB,IAAM,EAAa,EAAK,MAAM,CAAY,EACrC,IAAI,CAAC,IAAM,EAAS,QAAQ,CAAC,EAC7B,aAAa,EACZ,EAAW,EAAK,MAAM,CAAY,EACnC,IAAI,CAAC,IAAM,EAAS,QAAQ,CAAC,EAC7B,aAAa,EACZ,EAAiB,EAAK,MAAM,CAAY,EACzC,IAAI,CAAC,IAAM,EAAS,QAAQ,CAAC,EAC7B,aAAa,EACZ,GAAmB,EAAS,OAAO,EAAI,EAAS,KAAK,GAAK,EAC1D,EAAgB,EAAK,MAAM,CAAe,EAC3C,IAAI,CAAC,IAAM,EAAS,QAAQ,CAAC,EAC7B,aAAa,EAElB,QAAY,EAAS,EAAW,EAAS,KAAkB,EAAK,IAC5D,EACA,EACA,EACA,CACJ,EAAG,CACC,GAAI,IAAY,GAAa,IAAc,MACvC,MAEJ,QAAW,KAAa,EAAK,MAAM,EAAW,EAAU,CAAC,EAAG,CACxD,GAAI,GAAiB,EAAG,CACpB,QAAQ,MAAM,mDAAmD,EACjE,MAEJ,IAAM,GAAW,EAAY,GAAW,MACxC,EAAK,mBAAmB,IAAI,EAAS,CAAS,EAC9C,EAAK,mBAAmB,IAAI,EAAW,CAAO,IAK1D,OAAO,EAEf,CAMO,MAAM,CAAU,CACA,QAAnB,WAAW,CAAQ,EAAmB,CAAnB,qBAEZ,KAAI,CAAC,EAAY,EAA2B,CAC/C,IAAI,EACJ,GAAI,EAAK,aAAa,EAAE,kBAAoB,EACxC,EAAa,CAAC,IAAM,EAAI,EAAO,QAAQ,MAEvC,GAAa,CAAC,IAAM,EAAO,QAAQ,EAEvC,IAAM,EAAU,EAAK,MAAM,EAAK,WAAa,CAAC,EACzC,IAAI,CAAU,EACd,aAAa,EAClB,OAAO,IAAI,EAAU,CAAO,EAEpC,CAOO,MAAM,CAAU,CACA,OAAnB,WAAW,CAAQ,EAAiB,CAAjB,cAEnB,QAAQ,EAAW,CACf,MAAO,oBAAoB,KAAK,OAAO,gBAGpC,KAAI,CAAC,EAAY,EAAkC,CACtD,IAAM,EAAY,EAAK,aAAa,EACpC,IAAK,EACD,OAAO,KAEX,IAAM,EAAS,EAAK,MAAM,EAAK,UAAU,EACpC,IAAI,CAAC,IAAU,CACZ,IAAM,EAAc,EAAU,QAAQ,GAChC,EAAY,EAAU,QAAQ,EAAQ,GACtC,EAAc,EAAO,KAAK,EAAa,CAAS,EACtD,OAAO,IAAI,EAAM,EAAM,EAAO,CAAW,EAC5C,EACA,aAAa,EAClB,OAAO,IAAI,EAAU,CAAM,EAEnC,CAMO,MAAM,CAAU,CAER,SACA,UACA,QACA,gBACA,mBACA,oBACA,WACA,eACA,cACA,YACA,gBAXX,WAAW,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACT,CAXS,gBACA,iBACA,eACA,uBACA,0BACA,2BACA,kBACA,sBACA,qBACA,mBACA,6BAGJ,KAAI,CAAC,EAAa,EAA2B,CAChD,QAAQ,OAAO,EAAO,QAAQ,GAAK,CAAC,EACpC,QAAQ,OAAO,EAAO,QAAQ,GAAK,CAAC,EACpC,IAAM,EAAW,EAAO,QAAQ,EAC1B,EAAY,EAAO,QAAQ,EAC3B,EAAU,EAAO,QAAQ,EACzB,EAAkB,EAAO,QAAQ,EACjC,EAAqB,EAAO,QAAQ,EACpC,EAAsB,EAAO,QAAQ,EACrC,EAAa,EAAO,QAAQ,EAC5B,EAAiB,EAAO,QAAQ,EAChC,EAAgB,EAAO,QAAQ,EAC/B,EAAc,EAAO,QAAQ,EACnC,EAAO,QAAQ,EAAE,EACjB,IAAM,EAAkB,EAAO,QAAQ,EACvC,OAAO,IAAI,EACP,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACJ,EAER,CAQO,MAAM,CAAU,CAER,QACA,SACA,gBAHX,WAAW,CACA,EACA,EACA,EACT,CAHS,eACA,gBACA,uBAGX,UAAU,CAAC,EAAsC,CAC7C,GAAI,GAAW,KAAK,gBAChB,OAEJ,GAAI,EAAU,KAAK,QAAQ,OACvB,KAAK,QAAQ,GAAG,CAAO,GAAG,QAE9B,OAAO,KAAK,QAAQ,GAAG,EAAE,GAAG,QAGhC,cAAc,CAAC,EAAsC,CACjD,GAAI,EAAU,KAAK,QAAQ,OACvB,OAAO,KAAK,QAAQ,GAAG,CAAO,GAAG,gBAC9B,CACH,IAAM,EAAgB,EAAU,KAAK,QAAQ,OAC7C,OAAO,KAAK,SAAS,GAAG,CAAa,GAI7C,QAAQ,EAAW,CACf,MAAO,4BAA4B,KAAK,yBAGrC,KAAI,CAAC,EAAY,EAA2B,CAE/C,IAAI,EADc,EAAK,aAAa,EACJ,gBAC1B,EAAU,EAAK,MAAM,CAAe,EACrC,IAAI,CAAC,IAAM,CACR,MAAO,CACH,QAAS,EAAO,QAAQ,EACxB,YAAa,EAAO,QAAQ,CAChC,EACH,EACA,aAAa,EACZ,EAAe,EAAK,WAAa,EACnC,EAAqB,CAAC,EAC1B,GAAI,EAAe,EACf,GAAmB,EACnB,EAAW,EAAK,MAAM,CAAY,EAC7B,IAAI,CAAC,IAAM,EAAO,QAAQ,CAAC,EAC3B,aAAa,EAEtB,OAAO,IAAI,EAAU,EAAS,EAAU,CAAe,EAE/D,CCr0CO,MAAM,CAAK,CACd,OACA,MACA,MAEA,WAAW,CAAC,EAAgB,EAAc,EAA0C,CAChF,IAAM,EAAQ,IAAI,EAAK,OAAO,QAAQ,CAAe,CAAC,EACjD,UAAU,EAAE,EAAM,KAAe,CAC9B,IAAM,EAAQ,EAAM,iBAAiB,CAAS,EAC9C,GAAI,EACA,MAAO,CAAC,EAAM,IAAI,EAAK,KAAM,EAAM,EAAW,CAAK,CAAC,EAE3D,EACA,WAAW,EAEhB,KAAK,OAAS,EACd,KAAK,MAAQ,EACb,KAAK,MAAQ,cAIJ,KAAI,CAAC,EAA2E,CACzF,IAAO,EAAU,GAAY,MAAM,QAAQ,IAAI,CAC3C,MAAM,EAAS,QAAQ,EAAE,KAAK,CAAC,IAAM,EAAE,KAAK,CAAC,EAC7C,MAAM,EAAS,IAAI,EAAE,KAAK,CAAC,IAAM,EAAE,YAAY,CAAC,CACpD,CAAC,EAGD,SAAS,MAAM,IAAI,IAAI,SAAS,EAAS,KAAM,CAAQ,CAAC,EAGxD,IAAM,EAAQ,SAAS,cAAc,OAAO,EAC5C,EAAM,UAAY,IAAI,EAAS,uBAAuB,EAAS,SAC/D,SAAS,qBAAqB,MAAM,EAAE,GAAI,YAAY,CAAK,EAE3D,IAAM,EAAO,IAAI,EAAM,CAAQ,EAC/B,OAAO,IAAI,EAAK,EAAS,KAAM,EAAM,EAAS,KAAK,EAGvD,OAAO,CAAC,EAAgC,CACpC,OAAO,KAAK,MAAM,IAAI,CAAI,EAElC,CAEA,MAAM,CAAK,CACP,KACA,MACA,KACA,UACA,QAEA,WAAW,CAAC,EAAY,EAAc,EAAmB,EAAgB,CACrE,KAAK,KAAO,EACZ,KAAK,MAAQ,EACb,KAAK,KAAO,EACZ,KAAK,UAAY,EACjB,KAAK,QAAU,OAAO,cAAc,KAAK,SAAS,KAGlD,SAAQ,EAAW,CACnB,MAAO,GAAG,KAAK,KAAK,UAAU,KAAK,OAGvC,WAAW,EAAW,CAClB,IAAO,EAAS,GAAS,KAAK,MAAM,UAAU,EAC9C,MAAO,CACH,wBACA,iEACA,cAAc,OACd,QACJ,EAAE,KAAK;AAAA,CAAI,EAGf,aAAa,EAAmB,CAC5B,IAAM,EAAM,SAAS,cAAc,KAAK,EAIxC,OAHA,EAAI,YAAc,KAAK,QACvB,EAAI,MAAM,WAAa,KAAK,KAAK,OACjC,EAAI,UAAU,IAAI,cAAc,EACzB,EAEf,CAEO,MAAM,CAAQ,CACjB,MACA,KAEA,WAAW,CAAC,EAAuC,CAC/C,KAAK,MAAQ,EACb,KAAK,KAAO,IAAI,EAAK,EAAM,OAAO,CAAC,EAAE,KAAK,EAAG,CAAC,EAAM,IAAe,EAAO,EAAW,IAAI,QAGtF,UAAS,CAAC,EAAuB,CACpC,IAAM,EAAQ,IAAI,EAAK,CAAK,EACvB,IAAI,CAAC,IAAS,CAAC,EAAK,OAAQ,EAAK,KAAK,CAAU,EAChD,WAAW,EAChB,OAAO,IAAI,EAAQ,CAAK,EAI5B,MAAM,CAAC,EAA2B,CAC9B,GAAI,EAAS,QAAU,EACnB,OAAO,KAEX,IAAM,EAAQ,IAAI,OAAO,CAAQ,EAC3B,EAAQ,IAAI,EAAK,KAAK,KAAK,EAC5B,UAAU,EAAE,EAAY,KAAW,CAChC,IAAM,EAAgB,IAAI,EAAK,CAAK,EAC/B,OAAO,EAAE,EAAU,KAAU,CAC1B,OAAO,EAAS,OAAO,CAAK,GAAK,EACpC,EACA,WAAW,EAChB,OAAO,EAAc,MAAQ,EACvB,KACC,CAAC,EAAY,CAAa,EACpC,EACA,WAAW,EAChB,OAAO,IAAI,EAAQ,CAAK,EAG5B,IAAI,CAAC,EAAmC,CACpC,IAAM,EAAQ,EAAa,MAAM,sCAAsC,EACvE,IAAK,EACD,OAAO,KAEX,IAAQ,aAAY,YAAa,EAAM,OACvC,OAAO,KAAK,MAAM,IAAI,CAAW,GAAG,IAAI,CAAS,GAAK,KAG1D,aAAa,CAAC,EAGK,CACf,IAAM,EAAW,SAAS,cAAc,KAAK,EA+D7C,OA9DA,EAAS,UAAU,IAAI,UAAU,EACjC,IAAI,EAAK,KAAK,KAAK,EAAE,QAAQ,EAAE,EAAU,KAAW,CAEhD,IAAM,EAAU,SAAS,cAAc,KAAK,EAC5C,EAAQ,UAAU,IAAI,SAAS,EAC/B,EAAS,YAAY,CAAO,EAG5B,IAAM,EAAgB,SAAS,cAAc,KAAK,EAClD,EAAc,aACT,EAAI,iBAAiB,IAAI,CAAQ,EAC5B,EAAI,OAAO,KACX,EAAI,OAAO,QACf,cAAc,CACpB,EACA,IAAM,EAAkB,EAAS,OAAO,CAAC,EAAE,YAAY,EAAI,EAAS,MAAM,CAAC,EAC3E,EAAc,YACV,SAAS,eAAe,GAAG,MAAoB,EAAM,OAAO,CAChE,EACA,EAAc,UAAU,IAAI,gBAAgB,EAC5C,EAAc,iBAAiB,QAAS,CAAC,IAAU,CAC/C,GAAI,EAAI,iBAAiB,IAAI,CAAQ,EACjC,EAAI,iBAAiB,IAAI,EAAU,EAAK,EACxC,EAAa,MAAM,QAAU,OAC7B,EAAc,aACV,EAAI,OAAO,OAAO,cAAc,EAChC,EAAc,UAClB,MAEA,GAAI,iBAAiB,IAAI,EAAU,EAAI,EACvC,EAAa,MAAM,QAAU,GAC7B,EAAc,aACV,EAAI,OAAO,KAAK,cAAc,EAC9B,EAAc,UAClB,EAEP,EACD,EAAQ,YAAY,CAAa,EAGjC,IAAM,EAAiB,SAAS,eAAe,kBAAkB,EAC3D,EAAe,SAAS,cAAc,KAAK,EACjD,EAAa,UAAU,IAAI,eAAe,EAC1C,EAAa,UAAU,IAAI,CAAQ,EACnC,EAAa,MAAM,QAAU,EAAI,iBAAiB,IAAI,CAAQ,EAAI,GAAK,OACvE,IAAI,EAAK,CAAK,EAAE,QAAQ,EAAE,EAAM,KAAU,CACtC,IAAM,EAAc,SAAS,cAAc,KAAK,EAC1C,EAAW,GAAG,KAAY,IAChC,EAAY,YAAc,EAAK,QAC/B,EAAY,QAAQ,KAAO,EAC3B,EAAY,iBAAiB,QAAS,IAAM,GAAY,CAAI,CAAC,EAC7D,EAAY,iBAAiB,YAAa,CAAC,IAAU,CACjD,IAAM,EAAS,EAAM,OACrB,EAAe,UAAY,EAAO,QAAQ,KAC7C,EACD,EAAY,iBAAiB,aAAc,CAAC,IAAU,CAClD,EAAe,UAAY,GAC9B,EACD,EAAa,YAAY,CAAW,EACvC,EACD,EAAQ,YAAY,CAAY,EACnC,EACM,EAEf,CAEA,SAAS,EAAyB,CAE9B,EACA,EAAkB,IACE,CACpB,IAAI,EACJ,MAAO,IAAI,IAAS,CAChB,aAAa,CAAK,EAClB,EAAQ,OAAO,WAAW,IAAM,CAC5B,EAAK,MAAM,KAAM,CAAI,GACtB,CAAO,GAIlB,SAAS,EAAW,CAAC,EAAkB,CACnC,IAAM,EAAa,SAAS,eAAe,aAAa,EACxD,EAAW,UAAY,EAAK,YAAY,EAExC,IAAM,EAAc,SAAS,eAAe,cAAc,EACpD,EAAe,EAAK,UAAU,SAAS,EAAE,EAAE,YAAY,EAC7D,EAAY,UAAY,GAAG,EAAK,sCAAsC,UAEtE,IAAM,EAAgB,SAAS,eAAe,gBAAgB,EAC9D,EAAc,QAAQ,KAAO,EAAK,SAClC,EAAc,UAAU,EAGrB,SAAS,EAAK,CAAC,EAAkB,CAEpC,IAAM,EAAS,CACX,MAAO,EAAQ,KAAK,+BAA+B,EACnD,UAAW,EAAQ,KAAK,4BAA4B,EACpD,QAAS,EAAQ,KAAK,uBAAuB,EAC7C,KAAM,EAAQ,KAAK,4BAA4B,EAC/C,QAAS,EAAQ,KAAK,+BAA+B,EACrD,OAAQ,EAAQ,KAAK,2BAA2B,EAChD,UAAW,EAAQ,KAAK,6BAA6B,EACrD,MAAO,EAAQ,KAAK,2BAA2B,CACnD,EACM,EAAmB,IAAI,EAAK,EAAQ,MAAM,KAAK,CAAC,EACjD,IAAI,CAAC,IAAS,CAAC,EAAM,EAAI,CAAsB,EAC/C,WAAW,EACV,EAAM,CAAE,SAAQ,kBAAiB,EAGjC,EAAgB,SAAS,eAAe,gBAAgB,EAC9D,EAAc,iBAAiB,QAAS,CAAC,IAAU,CAC/C,IAAM,EAAa,EAAc,sBAAsB,EACvD,GACI,EAAM,QAAU,EAAW,MAC3B,EAAM,QAAU,EAAW,OAC3B,EAAM,QAAU,EAAW,KAC3B,EAAM,QAAU,EAAW,OAE3B,EAAc,MAAM,EAE3B,EACD,IAAM,EAAe,SAAS,eAAe,eAAe,EAC5D,EAAa,gBAAgB,EAAI,OAAO,MAAM,cAAc,CAAC,EAC7D,EAAa,iBAAiB,QAAS,IAAM,CACzC,EAAc,MAAM,EACvB,EACD,IAAM,EAAkB,SAAS,eAAe,mBAAmB,EACnE,EAAgB,gBAAgB,EAAI,OAAO,UAAU,cAAc,CAAC,EACpE,EAAgB,iBAAiB,QAAS,IAAM,CAC5C,UAAU,UAAU,UAAU,EAAc,QAAQ,IAAK,EAC5D,EACD,IAAM,EAAiB,SAAS,eAAe,kBAAkB,EACjE,EAAe,gBAAgB,EAAI,OAAO,QAAQ,cAAc,CAAC,EACjE,EAAe,iBAAiB,QAAS,IAAM,CAC3C,IAAI,EAAO,EAAQ,KAAK,EAAc,QAAQ,IAAK,EACnD,UAAU,UAAU,UAAU,EAAK,YAAY,CAAC,EACnD,EAGD,IAAM,EAAe,SAAS,eAAe,eAAe,EACtD,EAAc,SAAS,eAAe,qBAAqB,EAC3D,EAAe,IAAM,CACvB,IAAI,EAAgB,EAAQ,OAAO,EAAY,KAAK,EAAE,cAAc,CAAG,EACvE,EAAa,gBAAgB,CAAa,GAE9C,EAAY,iBAAiB,QAAS,GAAS,CAAY,CAAC,EAG5D,IAAM,EAAW,SAAS,eAAe,UAAU,EACnD,EAAS,YAAY,EAAI,OAAO,QAAQ,cAAc,CAAC,EACvD,EAAS,iBAAiB,QAAS,IAAM,CACrC,IAAM,EAAO,IAAI,EAAK,EAAI,iBAAiB,OAAO,CAAC,EAAE,KACjD,GACA,CAAC,EAAK,IAAS,GAAO,CAC1B,EACA,QAAW,KAAQ,EAAI,iBAAiB,KAAK,EACzC,EAAI,iBAAiB,IAAI,GAAO,CAAI,EAExC,EAAS,iBACJ,EAAO,EAAI,OAAO,UAAY,EAAI,OAAO,SAAS,cAAc,CACrE,EACA,EAAa,EAChB,EAGD,IAAM,EAAoB,SAAS,eAAe,cAAc,EAChE,EAAkB,gBAAgB,EAAI,OAAO,MAAM,cAAc,CAAC,EAClE,EAAkB,iBAAiB,QAAS,IAAM,CAE9C,EAAa,gBAAgB,EAC7B,aAAa,QACT,aACA,SAAS,gBAAgB,UAAU,OAAO,YAAY,EAAE,SAAS,CACrE,EACA,EAAa,EAChB,EAED,EAAa",
  "debugId": "A4D22A8EB87C498364756E2164756E21",
  "names": []
}