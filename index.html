<!DOCTYPE html>
<html>
  <head>
    <script type="module">
      import { parse as parseFont } from "./modules/opentype.module.js";

      let fonts = {}; // loaded fonts
      let fontsExpanded = {};
      const iconFold = "material-minus-box-outline";
      const iconFoldAll = "material-collapse-all-outline";
      const iconUnfold = "material-plus-box-outline";
      const iconUnfoldAll = "material-expand-all-outline";

      // load and register fonts and names mappings
      async function fontLoad(fontDesc) {
        // load font and metadata
        const [metadata, fontData] = await Promise.all([
          fetch(fontDesc.metadata).then((r) => r.json()),
          fetch(fontDesc.font).then((r) => r.arrayBuffer()),
        ]);

        // register font
        document.fonts.add(new FontFace(fontDesc.name, fontData));

        // create style
        const style = document.createElement("style");
        style.type = "text/css";
        style.innerText = `.${fontDesc.name} {font-family: "${fontDesc.name}"}`;
        document.getElementsByTagName("head")[0].appendChild(style);

        const font = parseFont(fontData);
        return [fontDesc.name, { font, names: metadata.names }];
      }

      function iconResolve(iconFullName) {
        const match = iconFullName.match(
          /(?<fontFamily>[^-]*)-(?<iconName>.*)/
        );
        if (!match) {
          return null;
        }
        const { fontFamily, iconName } = match.groups;
        const font = fonts[fontFamily];
        if (!font) {
          return null;
        }
        const codepoint = font.names[iconName];
        if (!codepoint) {
          return null;
        }
        const content = String.fromCodePoint(codepoint);
        return {
          fontFamily,
          name: iconName,
          codepoint,
          content,
          font: font.font,
          get glyph() {
            return this.font.charToGlyph(content);
          },
          toSVG() {
            const glyph = this.glyph,
              head = this.font.tables.head,
              padding = head.unitsPerEm / 10,
              width = head.xMax - head.xMin + 2 * padding,
              height = head.yMax - head.yMin + 2 * padding,
              baseline = head.yMax + padding,
              sideEm = Math.max(width, height);
            const side = 128,
              scale = side / sideEm,
              size = head.unitsPerEm * scale,
              x = ((sideEm - glyph.advanceWidth) / 2) * scale,
              y = baseline * scale;

            const svg = [
              '<?xml version="1.0"?>',
              `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${side} ${side}">`,
              `  ${this.glyph.getPath(x, y, size).toSVG()}`,
              "</svg>",
            ].join("\n");

            return svg;
          },
          toElement() {
            const div = document.createElement("div");
            div.textContent = this.content;
            div.style.fontFamily = this.fontFamily;
            div.classList.add("icon");
            return div;
          },
        };
      }

      // given list of {font: {name: content}} select names containing selector
      function iconsSelect(fonts, selector) {
        if (selector.length == 0) {
          return fonts;
        }
        const regex = new RegExp(selector);
        const selected = Object.entries(fonts)
          .map(([fontName, font]) => {
            const names = Object.fromEntries(
              Object.entries(font.names).filter(
                ([name, content]) => name.search(regex) >= 0
              )
            );
            return [fontName, { ...font, names }];
          })
          .filter(([fontName, font]) => Object.keys(font.names).length > 0);
        return Object.fromEntries(selected);
      }

      function iconsRender(icons) {
        const sections = document.createElement("div");
        Object.entries(icons).forEach(([fontName, font]) => {
          // section
          const section = document.createElement("div");
          section.classList.add("section");
          sections.appendChild(section);

          // header
          const sectionHeader = document.createElement("div");
          sectionHeader.appendChild(
            iconResolve(
              fontsExpanded[fontName] ? iconFold : iconUnfold
            )?.toElement()
          );
          sectionHeader.appendChild(
            document.createTextNode(
              `${fontName} (${Object.keys(font.names).length})`
            )
          );
          sectionHeader.classList.add("section-header");
          sectionHeader.addEventListener("click", (event) => {
            if (fontsExpanded[fontName]) {
              fontsExpanded[fontName] = false;
              sectionIcons.style.display = "none";
              sectionHeader.replaceChild(
                iconResolve(iconUnfold)?.toElement(),
                sectionHeader.firstChild
              );
            } else {
              fontsExpanded[fontName] = true;
              sectionIcons.style.display = "";
              sectionHeader.replaceChild(
                iconResolve(iconFold)?.toElement(),
                sectionHeader.firstChild
              );
            }
          });
          section.appendChild(sectionHeader);

          // icons
          const headerIconName = document.getElementById("header-icon-name");
          const sectionIcons = document.createElement("div");
          sectionIcons.classList.add("section-icons");
          sectionIcons.classList.add(fontName);
          sectionIcons.style.display = fontsExpanded[fontName] ? "" : "none";
          Object.entries(font.names).forEach(([name, codepoint]) => {
            const icon = document.createElement("div");
            const iconName = `${fontName}-${name}`;
            icon.textContent = String.fromCodePoint(codepoint);
            icon.dataset.name = iconName;
            icon.addEventListener("click", () => previewShow(iconName));
            icon.addEventListener("mouseover", (event) => {
              headerIconName.innerText = event.target.dataset.name;
            });
            icon.addEventListener("mouseleave", (event) => {
              headerIconName.innerText = "";
            });
            sectionIcons.appendChild(icon);
          });
          section.appendChild(sectionIcons);
        });
        return sections;
      }

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      function previewShow(iconName) {
        const icon = iconResolve(iconName);
        const previewSVG = document.getElementById("preview-svg");
        previewSVG.innerHTML = icon.toSVG();

        const previewName = document.getElementById("preview-name");
        previewName.textContent = iconName;

        const previewCopyName = document.getElementById("preview-copy-name");
        previewCopyName.dataset.name = iconName;

        const previewDialog = document.getElementById("preview-dialog");
        previewDialog.dataset.name = iconName;
        previewDialog.showModal();
      }

      function main(fonts) {
        // preview dialog
        const previewDialog = document.getElementById("preview-dialog");
        const previewClose = document.getElementById("preview-close");
        previewClose.replaceChildren(
          iconResolve("material-close-circle-outline").toElement()
        );
        previewClose.addEventListener("click", () => {
          previewDialog.close();
        });
        const previewCopyName = document.getElementById("preview-copy-name");
        previewCopyName.replaceChildren(
          iconResolve("material-clipboard-outline").toElement()
        );
        previewCopyName.addEventListener("click", () => {
          navigator.clipboard.writeText(previewDialog.dataset.name);
        });
        const previewCopySVG = document.getElementById("preview-copy-svg");
        previewCopySVG.replaceChildren(
          iconResolve("material-vector-curve").toElement()
        );
        previewCopySVG.addEventListener("click", () => {
          let icon = iconResolve(previewDialog.dataset.name);
          navigator.clipboard.writeText(icon.toSVG());
        });

        // update shown icons
        const result = document.getElementById("result");
        const resultUpdate = () => {
          result.replaceChildren(
            iconsRender(iconsSelect(fonts, selector.value))
          );
        };

        // selector
        const selector = document.getElementById("header-search-input");
        selector.addEventListener("input", debounce(resultUpdate));

        // expand/collapse
        const collapse = document.getElementById("collapse");
        collapse.appendChild(iconResolve(iconFoldAll)?.toElement());
        collapse.addEventListener("click", () => {
          const hide = Object.values(fontsExpanded).reduce(
            (acc, item) => acc || item,
            false
          );
          for (const name in fontsExpanded) {
            fontsExpanded[name] = !hide;
          }
          collapse.replaceChildren(
            iconResolve(hide ? iconUnfoldAll : iconFoldAll)?.toElement()
          );
          resultUpdate();
        });

        resultUpdate();
      }

      window.addEventListener("load", async (event) => {
        const fontDescsRequest = await fetch("descriptions.json");
        const fontDescs = await fontDescsRequest.json();
        const sources = Object.fromEntries(
          await Promise.all(fontDescs.map(fontLoad))
        );
        fonts = sources;
        fontsExpanded = Object.fromEntries(
          Object.keys(sources).map((name) => [name, true])
        );
        main(fonts);
      });
    </script>
    <style type="text/css">
      :root {
        --bg-hard: #1d2021;
        --bg: #282828;
        --bg-soft: #32302f;
        --bg_1: #3c3836;
        --bg_2: #504945;
        --bg_3: #665c54;
        --bg_4: #7c6f64;
        --bg-bold: #928374;
        --fg-bold: #a89984;
        --fg_2: #bdae93;
        --fg_1: #d5c4a1;
        --fg: #ebdbb2;
        --fg-1: #fbf1c7;

        --red-dark: #9d0006;
        --red: #cc241d;
        --red-light: #fb4934;

        --green-dark: #79740e;
        --green: #98971a;
        --green-light: #b8bb26;

        --yellow-dark: #b57614;
        --yellow: #d79921;
        --yellow-light: #fabd2f;

        --blue-dark: #076678;
        --blue: #458588;
        --blue-light: #83a598;

        --purple-dark: #8f3f71;
        --purple: #b16286;
        --purple-light: #d3869b;

        --aqua-dark: #427b58;
        --aqua: #689d6a;
        --aqua-light: #8ec07c;

        --orange-dark: #af3a03;
        --orange: #d65d0e;
        --orange-light: #fe8019;

        --header-height: 2em;

        scrollbar-color: var(--bg_4) var(--fg);
        font-family: "IBM Plex Sans", sans;
      }
      ::selection {
        background-color: var(--fg-bold);
      }
      body {
        background-color: var(--fg-1);
        margin: 0px;
      }

      .icon {
        display: inline-block;
        text-align: center;
        text-decoration: none;
        user-select: none;
        text-rendering: auto;
        padding: 0.2em;
        font-size: 0.9rem;
      }

      #header {
        position: fixed;
        top: 0;
        width: 100%;
        background-color: var(--fg_1);
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-color: var(--bg_4);
        box-shadow: 0 0 0.4em rgb(0 0 0 / 0.3);
        padding: 0.3rem;
        display: flex;
        justify-content: space-between;
        height: calc(var(--header-height) - 0.5rem);
      }
      #header-search {
        display: flex;
        align-items: center;
        background-color: var(--fg);
        border-color: var(--bg_4);
        border-style: solid;
        border-radius: 0.3rem;
        border-width: 1px;
        margin-right: 1rem;
      }
      #header-search-input {
        background-color: var(--fg);
        border-style: none;
        outline: none;
        margin-left: 0.3rem;
        margin-right: 0.3rem;
      }

      #preview-dialog {
        padding: 0;
        background-color: var(--fg-1);
        border-radius: 0.3rem;
        border-width: 1px;
        border-color: var(--bg_4);
        width: 60%;
        height: 60%;
      }
      #preview-dialog[open] {
        display: flex;
      }
      #preview-dialog::backdrop {
        background-color: rgb(0 0 0 / 0.3);
      }
      #preview-content {
        flex: 1;

        display: flex;
        flex-direction: column;
      }
      #preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;

        padding: 0.5rem;

        background-color: var(--fg_1);
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-color: var(--bg_4);
      }
      #preview-svg {
        flex: 1;
        display: flex;
        justify-content: space-around;
        align-items: center;
      }
      #preview-svg > svg {
        width: min(45vh, 45vw);
        height: min(45vh, 45vw);

        border-style: solid;
        border-color: var(--fg_1);
        border-radius: 0.3rem;
        border-width: 1px;

        background-color: var(--fg);

        fill: var(--purple);
        stroke: var(--purple-dark);
        stroke-width: 1px;
      }

      #result {
        display: flex;
        flex-direction: column;
        padding: 0.3rem;
        margin-top: var(--header-height);
      }
      .section-header {
        background-color: var(--fg);

        border-radius: 0.3rem;
        border-style: solid;
        border-width: 1px;
        border-color: var(--bg_4);

        padding: 0.3rem;
        margin-top: 0.3rem;
        margin-bottom: 0.3rem;
        user-select: none;
        font-size: 0.9rem;
      }
      .section-icons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        padding: 0.3rem;
      }
      .section-icons > div {
        font-size: 1.1rem;
        border-color: var(--fg-bold);
        border-radius: 0.3em;
        border-width: 1px;
        border-style: solid;
        padding: 0.5em;
        transition: all 200ms;
        width: 1em;
        height: 1em;
        cursor: pointer;
        user-select: none;
      }
      .section-icons > div:hover {
        background-color: var(--fg);
      }
      .section-icons > div:active {
        background-color: var(--fg_1);
      }
      .icon-name {
        display: inline;
        color: var(--bg_2);
        margin-right: 1rem;
        margin-left: 0.5rem;
      }

      .button {
        background-color: var(--fg);
        outline: none;
        border-radius: 0.3em;
        border-style: solid;
        border-width: 1px;
        border-color: var(--bg_4);
        transition: all 200ms;
        font-size: 1.1em;
      }
      .button:hover {
        background-color: var(--fg-1);
      }
      .button:active {
        background-color: var(--purple-light);
      }
    </style>
  </head>
  <body>
    <div id="header">
      <div id="header-search">
        <input id="header-search-input" />
        <div id="collapse"></div>
      </div>
      <div class="icon-name" id="header-icon-name"></div>
    </div>
    <dialog id="preview-dialog">
      <div id="preview-content">
        <div id="preview-header">
          <div class="icon-name" id="preview-name">icon-name</div>
          <div>
            <button class="button" id="preview-copy-svg">Copy SVG</button>
            <button class="button" id="preview-copy-name">Copy Name</button>
            <button class="button" id="preview-close">Close</button>
          </div>
        </div>
        <div id="preview-svg"></div>
      </div>
    </dialog>
    <div id="result"></div>
  </body>
</html>
