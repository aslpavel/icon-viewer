<!DOCTYPE html>
<html>
  <head>
    <script>
      "use strict";
      const fonts = [
        "awesome",
        "codicon",
        "fluent",
        "material",
        "phosphor",
        "remix",
        "weather",
      ];
      const fonts_shown = Object.fromEntries(fonts.map((name) => [name, true]));
      let icons = {};
      let icon_fold = "material-minus-box-outline";
      let icon_unfold = "material-plus-box-outline";

      // load and register fonts and names mappings
      async function loadFont(name) {
        // load font and metadata
        const [metadata, font] = await Promise.all([
          fetch(name + ".json").then((r) => r.json()),
          fetch(name + ".ttf").then((r) => r.arrayBuffer()),
        ]);

        // register font
        document.fonts.add(new FontFace(name, font));

        // create style
        const style = document.createElement("style");
        style.type = "text/css";
        style.innerText = `.${name} { font-family: "${name}"}`;
        document.getElementsByTagName("head")[0].appendChild(style);

        return [name, metadata.names];
      }

      function icon(name_full) {
        const div = document.createElement("div");
        const match = name_full.match(/(?<font>[^-]*)-(?<name>.*)/);
        if (!match) {
          return div;
        }
        const { font, name } = match.groups;
        const names = icons[font];
        if (!names) {
          return div;
        }
        const content = names[name];
        if (!content) {
          return div;
        }
        div.textContent = content;
        div.style.fontFamily = font;
        div.classList.add("icon");
        return div;
      }

      // given list of {font: {name: content}} select names containing selector
      function select(icons, selector) {
        if (selector.length == 0) {
          return icons;
        }
        const regex = new RegExp(selector);
        const selected = Object.entries(icons)
          .map(([font, names]) => {
            const names_selected = Object.entries(names).filter(
              ([name, content]) => name.search(regex) >= 0
            );
            return [font, Object.fromEntries(names_selected)];
          })
          .filter(([font, names]) => Object.keys(names).length > 0);
        return Object.fromEntries(selected);
      }

      function render_icons(icons) {
        const sections = document.createElement("div");
        Object.entries(icons).forEach(([font, names]) => {
          // section
          const section = document.createElement("div");
          section.classList.add("section");
          sections.appendChild(section);

          // header
          const section_header = document.createElement("div");
          section_header.appendChild(
            icon(fonts_shown[font] ? icon_fold : icon_unfold)
          );
          section_header.appendChild(
            document.createTextNode(`${font} (${Object.keys(names).length})`)
          );
          section_header.classList.add("section-header");
          section_header.addEventListener("click", (event) => {
            if (fonts_shown[font]) {
              fonts_shown[font] = false;
              section_icons.style.display = "none";
              section_header.replaceChild(
                icon(icon_unfold),
                section_header.firstChild
              );
            } else {
              fonts_shown[font] = true;
              section_icons.style.display = "";
              section_header.replaceChild(
                icon(icon_fold),
                section_header.firstChild
              );
            }
          });
          section.appendChild(section_header);

          // icons
          const description = document.getElementById("description");
          const section_icons = document.createElement("div");
          section_icons.classList.add("section-icons");
          section_icons.classList.add(font);
          section_icons.style.display = fonts_shown[font] ? "" : "none";
          Object.entries(names).forEach(([name, content]) => {
            const icon = document.createElement("div");
            icon.textContent = content;
            icon.dataset.name = name;
            icon.addEventListener("click", (event) => {
              navigator.clipboard.writeText(
                `${font}-${event.target.dataset.name}`
              );
            });
            icon.addEventListener("mouseover", (event) => {
              description.innerText = event.target.dataset.name;
            });
            icon.addEventListener("mouseleave", (event) => {
              description.innerText = "";
            });
            section_icons.appendChild(icon);
          });
          section.appendChild(section_icons);
        });
        return sections;
      }

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      window.addEventListener("load", (event) => {
        Promise.all(fonts.map(loadFont))
          .then(Object.fromEntries)
          .then((sources) => {
            icons = sources;

            // update shown icons
            const result = document.getElementById("result");
            const result_update = () => {
              result.replaceChildren(
                render_icons(select(sources, selector.value))
              );
            };

            // selector
            const selector = document.getElementById("selector");
            selector.addEventListener("input", debounce(result_update));

            // expand/collapse
            const collapse = document.getElementById("collapse");
            collapse.appendChild(icon("codicon-collapse-all"));
            collapse.addEventListener("click", () => {
              const hide = Object.values(fonts_shown).reduce(
                (acc, item) => acc || item,
                false
              );
              for (const name in fonts_shown) {
                fonts_shown[name] = !hide;
              }
              collapse.replaceChildren(
                icon(hide ? "codicon-expand-all" : "codicon-collapse-all")
              );
              result_update();
            });

            result_update();
          });
      });
    </script>
    <style type="text/css">
      :root {
        --bg-hard: #1d2021;
        --bg: #282828;
        --bg-soft: #32302f;
        --bg_1: #3c3836;
        --bg_2: #504945;
        --bg_3: #665c54;
        --bg_4: #7c6f64;
        --bg-bold: #928374;
        --fg-bold: #a89984;
        --fg_2: #bdae93;
        --fg_1: #d5c4a1;
        --fg: #ebdbb2;
        --fg-1: #fbf1c7;

        --red-dark: #9d0006;
        --red: #cc241d;
        --red-light: #fb4934;

        --green-dark: #79740e;
        --green: #98971a;
        --green-light: #b8bb26;

        --yellow-dark: #b57614;
        --yellow: #d79921;
        --yellow-light: #fabd2f;

        --blue-dark: #076678;
        --blue: #458588;
        --blue-light: #83a598;

        --purple-dark: #8f3f71;
        --purple: #b16286;
        --purple-light: #d3869b;

        --aqua-dark: #427b58;
        --aqua: #689d6a;
        --aqua-light: #8ec07c;

        --orange-dark: #af3a03;
        --orange: #d65d0e;
        --orange-light: #fe8019;

        --header-height: 2em;

        scrollbar-color: var(--bg_4) var(--fg);
      }
      body {
        font-family: "IBM Plex Sans", sans;
        background-color: var(--fg-1);
        margin: 0px;
      }
      ::selection {
        background-color: var(--fg-bold);
      }

      .icon {
        display: inline-block;
        text-align: center;
        text-decoration: none;
        user-select: none;
        text-rendering: auto;
        padding: 0.2em;
        font-size: 0.9rem;
      }

      #header {
        position: fixed;
        top: 0;
        width: 100%;
        background-color: var(--fg_1);
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-color: var(--bg_4);
        padding: 0.3rem;
        display: flex;
        justify-content: space-between;
        height: calc(var(--header-height) - 0.5rem);
      }
      #search {
        display: flex;
        align-items: center;
        background-color: var(--fg);
        border-color: var(--bg_4);
        border-style: solid;
        border-radius: 0.5rem;
        border-width: 1px;
        margin-right: 1rem;
      }
      #selector {
        background-color: var(--fg);
        border-style: none;
        outline: none;
        margin-left: 0.3rem;
        margin-right: 0.3rem;
      }
      #description {
        display: inline;
        color: var(--bg_2);
        margin-right: 1rem;
      }

      #result {
        display: flex;
        flex-direction: column;
        padding: 0.3rem;
        margin-top: var(--header-height);
      }
      .section-header {
        background-color: var(--fg);
        border-radius: 0.3rem;
        padding: 0.3rem;
        margin-top: 0.3rem;
        margin-bottom: 0.3rem;
        user-select: none;
        font-size: 0.9rem;
      }
      .section-icons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        padding: 0.3rem;
      }
      .section-icons > div {
        font-size: 1.1rem;
        border-color: var(--fg-bold);
        border-radius: 0.3em;
        border-width: 1px;
        border-style: solid;
        padding: 0.5em;
        transition: all 200ms;
        width: 1em;
        height: 1em;
        cursor: pointer;
        user-select: none;
      }
      .section-icons > div:hover {
        background-color: var(--fg);
      }
      .section-icons > div:active {
        background-color: var(--fg_1);
      }
    </style>
  </head>
  <body>
    <div id="header">
      <div id="search">
        <input id="selector" />
        <div id="collapse"></div>
      </div>
      <div id="description"></div>
    </div>
    <div id="result" />
  </body>
</html>
