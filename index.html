<!DOCTYPE html>
<html>
  <head>
    <script type="module">
      import { parse as parseFont } from "./modules/opentype.module.js";

      let fonts = {}; // loaded fonts
      let fontsExpanded = {};
      const iconFold = "material-minus-box-outline";
      const iconFoldAll = "material-collapse-all-outline";
      const iconUnfold = "material-plus-box-outline";
      const iconUnfoldAll = "material-expand-all-outline";

      // load and register fonts and names mappings
      async function fontLoad(fontDesc) {
        // load font and metadata
        const [metadata, fontData] = await Promise.all([
          fetch(fontDesc.metadata).then((r) => r.json()),
          fetch(fontDesc.font).then((r) => r.arrayBuffer()),
        ]);

        // register font
        document.fonts.add(new FontFace(fontDesc.name, fontData));

        // create style
        const style = document.createElement("style");
        style.type = "text/css";
        style.innerText = `.${fontDesc.name} {font-family: "${fontDesc.name}"}`;
        document.getElementsByTagName("head")[0].appendChild(style);

        const font = parseFont(fontData);
        return [fontDesc.name, { font, names: metadata.names }];
      }

      function iconResolve(iconFullName) {
        const match = iconFullName.match(
          /(?<fontFamily>[^-]*)-(?<iconName>.*)/
        );
        if (!match) {
          return null;
        }
        const { fontFamily, iconName } = match.groups;
        const font = fonts[fontFamily];
        if (!font) {
          return null;
        }
        const codepoint = font.names[iconName];
        if (!codepoint) {
          return null;
        }
        const content = String.fromCodePoint(codepoint);
        return {
          fontFamily,
          name: iconName,
          codepoint,
          content,
          font: font.font,
          get glyph() {
            return this.font.charToGlyph(content);
          },
          toSVG() {
            const glyph = this.glyph,
              head = this.font.tables.head,
              padding = head.unitsPerEm / 10,
              width = head.xMax - head.xMin + 2 * padding,
              height = head.yMax - head.yMin + 2 * padding,
              baseline = head.yMax + padding,
              sideEm = Math.max(width, height);
            const side = 128,
              scale = side / sideEm,
              size = head.unitsPerEm * scale,
              x = ((sideEm - glyph.advanceWidth) / 2) * scale,
              y = baseline * scale;

            const svg = [
              '<?xml version="1.0"?>',
              `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${side} ${side}">`,
              `  ${this.glyph.getPath(x, y, size).toSVG()}`,
              "</svg>",
            ].join("\n");

            return svg;
          },
          toElement() {
            const div = document.createElement("div");
            div.textContent = this.content;
            div.style.fontFamily = this.fontFamily;
            div.classList.add("icon-resolve");
            return div;
          },
        };
      }

      // given list of {font: {name: content}} select names containing selector
      function iconsSelect(fonts, selector) {
        if (selector.length == 0) {
          return fonts;
        }
        const regex = new RegExp(selector);
        const selected = Object.entries(fonts)
          .map(([fontName, font]) => {
            const names = Object.fromEntries(
              Object.entries(font.names).filter(
                ([name, content]) => name.search(regex) >= 0
              )
            );
            return [fontName, { ...font, names }];
          })
          .filter(([fontName, font]) => Object.keys(font.names).length > 0);
        return Object.fromEntries(selected);
      }

      function iconsRender(icons) {
        const sections = document.createElement("div");
        sections.classList.add("sections");
        Object.entries(icons).forEach(([fontName, font]) => {
          // section
          const section = document.createElement("div");
          section.classList.add("section");
          sections.appendChild(section);

          // header
          const sectionHeader = document.createElement("div");
          sectionHeader.appendChild(
            iconResolve(
              fontsExpanded[fontName] ? iconFold : iconUnfold
            )?.toElement()
          );
          const fontNameCapital =
            fontName.charAt(0).toUpperCase() + fontName.slice(1);
          sectionHeader.appendChild(
            document.createTextNode(
              `${fontNameCapital} (${Object.keys(font.names).length})`
            )
          );
          sectionHeader.classList.add("section-header");
          sectionHeader.addEventListener("click", (event) => {
            if (fontsExpanded[fontName]) {
              fontsExpanded[fontName] = false;
              sectionIcons.style.display = "none";
              sectionHeader.replaceChild(
                iconResolve(iconUnfold)?.toElement(),
                sectionHeader.firstChild
              );
            } else {
              fontsExpanded[fontName] = true;
              sectionIcons.style.display = "";
              sectionHeader.replaceChild(
                iconResolve(iconFold)?.toElement(),
                sectionHeader.firstChild
              );
            }
          });
          section.appendChild(sectionHeader);

          // icons
          const headerIconName = document.getElementById("header-icon-name");
          const sectionIcons = document.createElement("div");
          sectionIcons.classList.add("section-icons");
          sectionIcons.classList.add(fontName);
          sectionIcons.style.display = fontsExpanded[fontName] ? "" : "none";
          Object.entries(font.names).forEach(([name, codepoint]) => {
            const icon = document.createElement("div");
            const iconName = `${fontName}-${name}`;
            icon.textContent = String.fromCodePoint(codepoint);
            icon.dataset.name = iconName;
            icon.addEventListener("click", () => previewShow(iconName));
            icon.addEventListener("mouseover", (event) => {
              headerIconName.innerText = event.target.dataset.name;
            });
            icon.addEventListener("mouseleave", (event) => {
              headerIconName.innerText = "";
            });
            sectionIcons.appendChild(icon);
          });
          section.appendChild(sectionIcons);
        });
        return sections;
      }

      function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      }

      function previewShow(iconName) {
        const icon = iconResolve(iconName);
        const previewSVG = document.getElementById("preview-svg");
        previewSVG.innerHTML = icon.toSVG();

        const previewName = document.getElementById("preview-name");
        previewName.textContent = iconName;

        const previewCopyName = document.getElementById("preview-copy-name");
        previewCopyName.dataset.name = iconName;

        const previewDialog = document.getElementById("preview-dialog");
        previewDialog.dataset.name = iconName;
        previewDialog.showModal();
      }

      function main(fonts) {
        // preview dialog
        const previewDialog = document.getElementById("preview-dialog");
        const previewClose = document.getElementById("preview-close");
        previewClose.replaceChildren(
          iconResolve("material-close-circle-outline").toElement()
        );
        previewClose.addEventListener("click", () => {
          previewDialog.close();
        });
        const previewCopyName = document.getElementById("preview-copy-name");
        previewCopyName.replaceChildren(
          iconResolve("material-clipboard-outline").toElement()
        );
        previewCopyName.addEventListener("click", () => {
          navigator.clipboard.writeText(previewDialog.dataset.name);
        });
        const previewCopySVG = document.getElementById("preview-copy-svg");
        previewCopySVG.replaceChildren(
          iconResolve("material-vector-curve").toElement()
        );
        previewCopySVG.addEventListener("click", () => {
          let icon = iconResolve(previewDialog.dataset.name);
          navigator.clipboard.writeText(icon.toSVG());
        });

        // update shown icons
        const result = document.getElementById("result");
        const resultUpdate = () => {
          result.replaceChildren(
            iconsRender(iconsSelect(fonts, selector.value))
          );
        };

        // selector
        const selector = document.getElementById("header-search-input");
        selector.addEventListener("input", debounce(resultUpdate));

        // expand/collapse
        const collapse = document.getElementById("collapse");
        collapse.appendChild(iconResolve(iconFoldAll)?.toElement());
        collapse.addEventListener("click", () => {
          const hide = Object.values(fontsExpanded).reduce(
            (acc, item) => acc || item,
            false
          );
          for (const name in fontsExpanded) {
            fontsExpanded[name] = !hide;
          }
          collapse.replaceChildren(
            iconResolve(hide ? iconUnfoldAll : iconFoldAll)?.toElement()
          );
          resultUpdate();
        });

        resultUpdate();
      }

      window.addEventListener("load", async (event) => {
        const fontDescsRequest = await fetch("descriptions.json");
        const fontDescs = await fontDescsRequest.json();
        const sources = Object.fromEntries(
          await Promise.all(fontDescs.map(fontLoad))
        );
        fonts = sources;
        fontsExpanded = Object.fromEntries(
          Object.keys(sources).map((name) => [name, true])
        );
        main(fonts);
      });
    </script>
    <style type="text/css">
      :root {
        /* defaults */
        font-family: "IBM Plex Sans", sans;

        /* sizes */
        --border-width: 1px;
        --border-radius: 0.4rem;
        --icon-size: 1.3rem;
        --header-height: 3rem;
        --header-padding: 0.5rem;

        /* Color Theme */
        --foreground-color: #282828; /* bg */
        --background-color: #fbf1c7; /* fg-1 */
        --header-color: #d5c4a1; /* fg_1 */
        --section-header-color: #ebdbb2; /* fg */
        --border-color: #7c6f64; /* bg_4 */
        --icon-border-color: #a89984; /* fg-bold */
        --icon-background-color: #f2e5bc;
        --icon-hover-color: #ebdbb2; /* fg */
        --icon-active-color: #d5c4a1; /* fg_1 */
        --selection-color: #bdae93; /* fg_2 */
        --preview-fill-color: #b16286; /* purple */
        --preview-stroke-color: #8f3f71; /* purple-dark */
        scrollbar-color: var(--border-color) var(--section-header-color);
      }
      ::selection {
        background-color: var(--selection-color);
      }
      body {
        color: var(--foreground-color);
        background-color: var(--background-color);
        margin: 0px;
      }

      .icon-resolve {
        display: inline-block;
        text-align: center;
        text-decoration: none;
        text-rendering: auto;
        user-select: none;
        font-size: calc(var(--icon-size) * 4 / 5);
      }

      /* Header */
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;

        background-color: var(--header-color);

        border-bottom-style: solid;
        border-bottom-width: var(--border-width);
        border-color: var(--border-color);
        box-shadow: 0 0 0.5rem rgb(0 0 0 / 0.2);

        box-sizing: border-box;
        padding: var(--header-padding);
        height: var(--header-height);
      }
      .icon-name {
        display: inline;
        color: var(--foreground-color);
        margin-left: var(--header-padding);
      }
      #header {
        position: fixed;
        top: 0;
        width: 100%;
      }
      #header-search {
        display: flex;
        align-items: center;

        background-color: var(--section-header-color);

        border-color: var(--border-color);
        border-style: solid;
        border-radius: var(--border-radius);
        border-width: var(--border-width);

        height: calc(var(--header-height) - var(--header-padding) * 4);
        padding: var(--header-padding);
      }
      #header-search-input {
        background-color: var(--section-header-color);
        border-style: none;
        outline: none;
      }

      /* Preview */
      #preview-dialog {
        padding: 0;
        background-color: var(--background-color);
        border-radius: var(--border-radius);
        border-width: var(--border-width);
        border-color: var(--border-color);
        width: 60%;
        height: 60%;
      }
      #preview-dialog[open] {
        display: flex;
      }
      #preview-dialog::backdrop {
        background-color: rgb(0 0 0 / 0.3);
      }
      #preview-content {
        flex: 1;

        display: flex;
        flex-direction: column;
      }
      #preview-buttons {
        display: flex;
        gap: var(--header-padding);
      }
      .preview-button {
        outline: none;
        transition: all 300ms;
        cursor: pointer;
        padding: 0;

        border-style: solid;
        border-radius: var(--border-radius);
        border-width: var(--border-width);
        border-color: var(--border-color);

        height: calc(var(--header-height) - var(--header-padding) * 2);
        width: calc(var(--header-height) - var(--header-padding) * 2);

        color: var(--foreground-color);
        background-color: var(--section-header-color);
      }
      .preview-button:hover {
        background-color: var(--icon-background-color);
      }
      .preview-button:active {
        background-color: var(--background-color);
      }
      .preview-button > .icon-resolve {
        font-size: var(--icon-size);
      }
      #preview-svg {
        flex: 1;

        display: flex;
        justify-content: space-around;
        align-items: center;
      }
      #preview-svg > svg {
        width: min(calc(50vh - var(--header-height)), 50vw);
        height: min(calc(50vh - var(--header-height)), 50vw);

        border-style: solid;
        border-color: var(--icon-border-color);
        border-radius: var(--border-radius);
        border-width: var(--border-width);

        background-color: var(--icon-background-color);

        /* svg */
        fill: var(--preview-fill-color);
        stroke: var(--preview-stroke-color);
        stroke-width: 1px; /* size SVG coordiante system (keep it static) */
      }

      /* Result Icons */
      #result {
        color: var(--foreground-color);
        margin-top: var(--header-height);
        padding: var(--header-padding);
      }
      .sections {
        display: flex;
        flex-direction: column;
        gap: var(--header-padding);
      }
      .section-header {
        background-color: var(--section-header-color);

        border-style: solid;
        border-radius: var(--border-radius);
        border-width: var(--border-width);
        border-color: var(--border-color);

        display: flex;
        align-items: center;
        gap: var(--header-padding);

        padding: var(--header-padding);
        user-select: none;
      }
      .section-icons {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: calc(var(--icon-size) / 3);

        padding: calc(var(--icon-size) / 3);
      }
      .section-icons > div {
        display: flex;
        justify-content: center;
        align-items: center;

        background-color: var(--icon-background-color);
        cursor: pointer;
        user-select: none;
        transition: all 200ms;

        border-color: var(--icon-border-color);
        border-radius: var(--border-radius);
        border-width: var(--border-width);
        border-style: solid;

        font-size: var(--icon-size);
        padding: calc(var(--icon-size) / 3);
        width: var(--icon-size);
        height: var(--icon-size);
      }
      .section-icons > div:hover {
        background-color: var(--icon-hover-color);
      }
      .section-icons > div:active {
        background-color: var(--icon-active-color);
      }
    </style>
  </head>
  <body>
    <!-- header -->
    <div class="header" id="header">
      <div id="header-search">
        <input id="header-search-input" />
        <div id="collapse"></div>
      </div>
      <div class="icon-name" id="header-icon-name"></div>
    </div>

    <!-- result icons -->
    <div id="result"></div>

    <!-- preview -->
    <dialog id="preview-dialog">
      <div id="preview-content">
        <div class="header" id="preview-header">
          <div class="icon-name" id="preview-name">icon-name</div>
          <div id="preview-buttons">
            <button
              class="preview-button"
              id="preview-copy-svg"
              title="Copy SVG"
            ></button>
            <button
              class="preview-button"
              id="preview-copy-name"
              title="Copy Name"
            ></button>
            <button
              class="preview-button"
              id="preview-close"
              title="Close Preview"
            ></button>
          </div>
        </div>
        <div id="preview-svg"></div>
      </div>
    </dialog>
  </body>
</html>
